{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Documentation","text":""},{"location":"#thunderbird.github","title":"<code>github</code>","text":"<p>A script to download files from GitHub, preserving the original commit dates.</p> <p>Created on 2023-12-12</p> <p>@author: wf</p> <p>Usage: python github.py   ..."},{"location":"#thunderbird.github.GithubDownloader","title":"<code>GithubDownloader</code>","text":"<p>Downloader for github files with timestamp preservation.</p> Source code in <code>thunderbird/github.py</code> <pre><code>class GithubDownloader:\n    \"\"\"Downloader for github files with timestamp preservation.\"\"\"\n\n    def __init__(self, target_dir: str, urls: List[str]) -&gt; None:\n        \"\"\"\n        Initializes the GithubDownloader with a target directory and a dictionary mapping URLs to repositories.\n\n        Args:\n            target_dir: The directory where files will be downloaded.\n            urls: A dictionary of URLs to their corresponding repositories.\n        \"\"\"\n        self.target_dir = target_dir\n        os.makedirs(target_dir, exist_ok=True)\n        self.file_map = {}\n        for url in urls:\n            self.file_map[url] = GithubFile(url)\n\n    def download_files(self) -&gt; None:\n        \"\"\"Downloads all files based on the prepared download gh_fileurations.\"\"\"\n        for _url, gh_file in self.file_map.items():\n            self.download_file(gh_file)\n\n    def download_file(self, gh_file: GithubFile) -&gt; None:\n        \"\"\"\n        Downloads a file based on the provided download gh_fileuration.\n\n        Args:\n            gh_file(GithubFile): the download url, repo,filepath etc\n        \"\"\"\n        response = requests.get(gh_file.raw_url)\n        checkmark = \"\u2705\" if response.status_code == 200 else \"\u274c\"\n        status_str = \"successful\" if response.status_code == 200 else \"failed\"\n        gh_file.add_msg(f\"{checkmark} Download {status_str}\")\n\n        if response.status_code == 200:\n            local_path = os.path.join(self.target_dir, gh_file.file_path)\n            # Create parent directory if it doesn't exist\n            os.makedirs(os.path.dirname(local_path), exist_ok=True)\n\n            with open(local_path, \"wb\") as file:\n                file.write(response.content)\n            gh_file.get_commit_date()\n            gh_file.set_file_timestamp(self.target_dir)\n\n    def set_file_timestamp(self, filepath: str, timestamp: str) -&gt; None:\n        \"\"\"Sets the file's timestamp.\n\n        Args:\n            filepath: The path to the local file.\n            timestamp: The timestamp string in ISO format.\n        \"\"\"\n        timestamp = datetime.strptime(timestamp, \"%Y-%m-%dT%H:%M:%SZ\")\n        mod_time = timestamp.timestamp()\n        os.utime(filepath, (mod_time, mod_time))\n\n    @classmethod\n    def from_args(cls, args: list) -&gt; \"GithubDownloader\":\n        \"\"\"\n        Creates an instance of GithubDownloader from command line arguments.\n\n        Args:\n            args: A list of command line arguments.\n\n        Returns:\n            An instance of GithubDownloader.\n\n        Raises:\n            ValueError: If insufficient arguments are provided.\n        \"\"\"\n        if len(args) &lt; 2:\n            raise ValueError(\"Insufficient arguments. Expected at least 2 arguments.\")\n        target_dir = args[0]\n        urls = args[1:]\n        return cls(target_dir, urls)\n</code></pre>"},{"location":"#thunderbird.github.GithubDownloader.__init__","title":"<code>__init__(target_dir, urls)</code>","text":"<p>Initializes the GithubDownloader with a target directory and a dictionary mapping URLs to repositories.</p> <p>Parameters:</p> Name Type Description Default <code>target_dir</code> <code>str</code> <p>The directory where files will be downloaded.</p> required <code>urls</code> <code>List[str]</code> <p>A dictionary of URLs to their corresponding repositories.</p> required Source code in <code>thunderbird/github.py</code> <pre><code>def __init__(self, target_dir: str, urls: List[str]) -&gt; None:\n    \"\"\"\n    Initializes the GithubDownloader with a target directory and a dictionary mapping URLs to repositories.\n\n    Args:\n        target_dir: The directory where files will be downloaded.\n        urls: A dictionary of URLs to their corresponding repositories.\n    \"\"\"\n    self.target_dir = target_dir\n    os.makedirs(target_dir, exist_ok=True)\n    self.file_map = {}\n    for url in urls:\n        self.file_map[url] = GithubFile(url)\n</code></pre>"},{"location":"#thunderbird.github.GithubDownloader.download_file","title":"<code>download_file(gh_file)</code>","text":"<p>Downloads a file based on the provided download gh_fileuration.</p> <p>Parameters:</p> Name Type Description Default <code>gh_file(GithubFile)</code> <p>the download url, repo,filepath etc</p> required Source code in <code>thunderbird/github.py</code> <pre><code>def download_file(self, gh_file: GithubFile) -&gt; None:\n    \"\"\"\n    Downloads a file based on the provided download gh_fileuration.\n\n    Args:\n        gh_file(GithubFile): the download url, repo,filepath etc\n    \"\"\"\n    response = requests.get(gh_file.raw_url)\n    checkmark = \"\u2705\" if response.status_code == 200 else \"\u274c\"\n    status_str = \"successful\" if response.status_code == 200 else \"failed\"\n    gh_file.add_msg(f\"{checkmark} Download {status_str}\")\n\n    if response.status_code == 200:\n        local_path = os.path.join(self.target_dir, gh_file.file_path)\n        # Create parent directory if it doesn't exist\n        os.makedirs(os.path.dirname(local_path), exist_ok=True)\n\n        with open(local_path, \"wb\") as file:\n            file.write(response.content)\n        gh_file.get_commit_date()\n        gh_file.set_file_timestamp(self.target_dir)\n</code></pre>"},{"location":"#thunderbird.github.GithubDownloader.download_files","title":"<code>download_files()</code>","text":"<p>Downloads all files based on the prepared download gh_fileurations.</p> Source code in <code>thunderbird/github.py</code> <pre><code>def download_files(self) -&gt; None:\n    \"\"\"Downloads all files based on the prepared download gh_fileurations.\"\"\"\n    for _url, gh_file in self.file_map.items():\n        self.download_file(gh_file)\n</code></pre>"},{"location":"#thunderbird.github.GithubDownloader.from_args","title":"<code>from_args(args)</code>  <code>classmethod</code>","text":"<p>Creates an instance of GithubDownloader from command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list</code> <p>A list of command line arguments.</p> required <p>Returns:</p> Type Description <code>GithubDownloader</code> <p>An instance of GithubDownloader.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If insufficient arguments are provided.</p> Source code in <code>thunderbird/github.py</code> <pre><code>@classmethod\ndef from_args(cls, args: list) -&gt; \"GithubDownloader\":\n    \"\"\"\n    Creates an instance of GithubDownloader from command line arguments.\n\n    Args:\n        args: A list of command line arguments.\n\n    Returns:\n        An instance of GithubDownloader.\n\n    Raises:\n        ValueError: If insufficient arguments are provided.\n    \"\"\"\n    if len(args) &lt; 2:\n        raise ValueError(\"Insufficient arguments. Expected at least 2 arguments.\")\n    target_dir = args[0]\n    urls = args[1:]\n    return cls(target_dir, urls)\n</code></pre>"},{"location":"#thunderbird.github.GithubDownloader.set_file_timestamp","title":"<code>set_file_timestamp(filepath, timestamp)</code>","text":"<p>Sets the file's timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the local file.</p> required <code>timestamp</code> <code>str</code> <p>The timestamp string in ISO format.</p> required Source code in <code>thunderbird/github.py</code> <pre><code>def set_file_timestamp(self, filepath: str, timestamp: str) -&gt; None:\n    \"\"\"Sets the file's timestamp.\n\n    Args:\n        filepath: The path to the local file.\n        timestamp: The timestamp string in ISO format.\n    \"\"\"\n    timestamp = datetime.strptime(timestamp, \"%Y-%m-%dT%H:%M:%SZ\")\n    mod_time = timestamp.timestamp()\n    os.utime(filepath, (mod_time, mod_time))\n</code></pre>"},{"location":"#thunderbird.github.GithubFile","title":"<code>GithubFile</code>  <code>dataclass</code>","text":"<p>Data class to hold the details for each github file.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>The URL to the file.</p> <code>repo</code> <code>str</code> <p>The repository name.</p> <code>file_path</code> <code>str</code> <p>The relative path of the file.</p> <code>status_msg</code> <code>Optional[str]</code> <p>A status message regarding the download.</p> <code>timestamp</code> <code>Optional[datetime]</code> <p>The timestamp of the last commit.</p> <code>timestamp_iso</code> <code>Optional[str]</code> <p>timestamp in iso format</p> Source code in <code>thunderbird/github.py</code> <pre><code>@dataclass\nclass GithubFile:\n    \"\"\"\n    Data class to hold the details for each github file.\n\n    Attributes:\n        url (str): The URL to the file.\n        repo (str): The repository name.\n        file_path (str): The relative path of the file.\n        status_msg (Optional[str]): A status message regarding the download.\n        timestamp (Optional[datetime]): The timestamp of the last commit.\n        timestamp_iso (Optional[str]): timestamp in iso format\n    \"\"\"\n\n    url: str\n    repo: str = field(init=False)\n    branch: str = field(init=False)\n    file_path: str = field(init=False)\n    raw_url: str = field(init=False)\n    status_msg: Optional[str] = None\n    timestamp: Optional[datetime] = None\n    timestamp_iso: Optional[str] = None  # ISO format timestamp\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization to parse the URL and construct the raw URL for downloading the file.\n        \"\"\"\n        pattern = r\"https://github\\.com/(?P&lt;repo&gt;[^/]+/[^/]+)/blob/(?P&lt;branch&gt;[^/]+)/(?P&lt;file_path&gt;.+)\"\n        match = re.match(pattern, self.url)\n        if match:\n            self.repo = match.group(\"repo\")\n            self.branch = match.group(\"branch\")\n            self.file_path = match.group(\"file_path\")\n            self.raw_url = f\"https://raw.githubusercontent.com/{self.repo}/{self.branch}/{self.file_path}\"\n        else:\n            raise ValueError(f\"URL does not match expected format: {self.url}\")\n\n    def to_json(self):\n        \"\"\"Converts the me to JSON.\"\"\"\n        return json.dumps(asdict(self), default=str)\n\n    def get_commit_date(self) -&gt; Optional[str]:\n        \"\"\"\n        Gets the last commit date of my file from GitHub\n        and sets my timestamp accordingly\n\n        \"\"\"\n        api_url = (\n            f\"https://api.github.com/repos/{self.repo}/commits?path={self.file_path}\"\n        )\n        response = requests.get(api_url)\n        if response.status_code == 200:\n            commits = response.json()\n            commit = commits[0][\"commit\"][\"committer\"][\"date\"]\n            self.timestamp = datetime.strptime(commit, \"%Y-%m-%dT%H:%M:%SZ\")\n            self.timestamp_iso = self.timestamp.isoformat()\n        else:\n            msg = f\"can't access commit date for {self.repo}:{self.file_path}\"\n            self.add_msg(msg)\n            self.timestamp = None\n\n    def set_file_timestamp(self, target_dir: str):\n        \"\"\"Sets the file's timestamp based on the commit date.\"\"\"\n        if self.timestamp and isinstance(self.timestamp, datetime):\n            mod_time = self.timestamp.timestamp()\n            local_path = os.path.join(target_dir, self.file_path)\n            if os.path.isfile(local_path):\n                os.utime(local_path, (mod_time, mod_time))\n\n    def add_msg(self, msg):\n        if self.status_msg is None:\n            self.status_msg = \"\"\n            delim = \"\"\n        else:\n            delim = \"\\n\"\n        self.status_msg = f\"{self.status_msg}{delim}{msg}\"\n</code></pre>"},{"location":"#thunderbird.github.GithubFile.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization to parse the URL and construct the raw URL for downloading the file.</p> Source code in <code>thunderbird/github.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization to parse the URL and construct the raw URL for downloading the file.\n    \"\"\"\n    pattern = r\"https://github\\.com/(?P&lt;repo&gt;[^/]+/[^/]+)/blob/(?P&lt;branch&gt;[^/]+)/(?P&lt;file_path&gt;.+)\"\n    match = re.match(pattern, self.url)\n    if match:\n        self.repo = match.group(\"repo\")\n        self.branch = match.group(\"branch\")\n        self.file_path = match.group(\"file_path\")\n        self.raw_url = f\"https://raw.githubusercontent.com/{self.repo}/{self.branch}/{self.file_path}\"\n    else:\n        raise ValueError(f\"URL does not match expected format: {self.url}\")\n</code></pre>"},{"location":"#thunderbird.github.GithubFile.get_commit_date","title":"<code>get_commit_date()</code>","text":"<p>Gets the last commit date of my file from GitHub and sets my timestamp accordingly</p> Source code in <code>thunderbird/github.py</code> <pre><code>def get_commit_date(self) -&gt; Optional[str]:\n    \"\"\"\n    Gets the last commit date of my file from GitHub\n    and sets my timestamp accordingly\n\n    \"\"\"\n    api_url = (\n        f\"https://api.github.com/repos/{self.repo}/commits?path={self.file_path}\"\n    )\n    response = requests.get(api_url)\n    if response.status_code == 200:\n        commits = response.json()\n        commit = commits[0][\"commit\"][\"committer\"][\"date\"]\n        self.timestamp = datetime.strptime(commit, \"%Y-%m-%dT%H:%M:%SZ\")\n        self.timestamp_iso = self.timestamp.isoformat()\n    else:\n        msg = f\"can't access commit date for {self.repo}:{self.file_path}\"\n        self.add_msg(msg)\n        self.timestamp = None\n</code></pre>"},{"location":"#thunderbird.github.GithubFile.set_file_timestamp","title":"<code>set_file_timestamp(target_dir)</code>","text":"<p>Sets the file's timestamp based on the commit date.</p> Source code in <code>thunderbird/github.py</code> <pre><code>def set_file_timestamp(self, target_dir: str):\n    \"\"\"Sets the file's timestamp based on the commit date.\"\"\"\n    if self.timestamp and isinstance(self.timestamp, datetime):\n        mod_time = self.timestamp.timestamp()\n        local_path = os.path.join(target_dir, self.file_path)\n        if os.path.isfile(local_path):\n            os.utime(local_path, (mod_time, mod_time))\n</code></pre>"},{"location":"#thunderbird.github.GithubFile.to_json","title":"<code>to_json()</code>","text":"<p>Converts the me to JSON.</p> Source code in <code>thunderbird/github.py</code> <pre><code>def to_json(self):\n    \"\"\"Converts the me to JSON.\"\"\"\n    return json.dumps(asdict(self), default=str)\n</code></pre>"},{"location":"#thunderbird.github.main","title":"<code>main()</code>","text":"<p>Main function to run the script.</p> Source code in <code>thunderbird/github.py</code> <pre><code>def main():\n    \"\"\"\n    Main function to run the script.\n    \"\"\"\n    downloader = GithubDownloader.from_args(sys.argv[1:])\n    downloader.download_files()\n</code></pre>"},{"location":"#thunderbird.mail","title":"<code>mail</code>","text":"<p>Created on 2020-10-24</p> <p>@author: wf</p>"},{"location":"#thunderbird.mail.IndexingState","title":"<code>IndexingState</code>  <code>dataclass</code>","text":"<p>State of the index_db for all mailboxes</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@dataclass\nclass IndexingState:\n    \"\"\"\n    State of the index_db for all mailboxes\n    \"\"\"\n    total_mailboxes: int = 0\n    total_successes: int = 0\n    total_errors: int = 0\n    force_create: bool = False\n    index_up_to_date = False\n    success: Counter = field(default_factory=Counter) \n    errors: Dict[str, Exception] = field(default_factory=dict)\n    gloda_db_update_time: Optional[datetime] = None\n    index_db_update_time: Optional[datetime] = None\n    msg: str = \"\"\n\n    def update_msg(self):\n        msg=f\"{self.total_successes}/{self.total_mailboxes} updated - {self.total_errors} errors\"\n        return msg\n\n    @property\n    def error_rate(self):\n        \"\"\"\n        Calculate the error rate in percent\n        \"\"\"\n        if self.total_mailboxes &gt; 0:\n            error_rate = self.total_errors / self.total_mailboxes *100\n        else:\n            error_rate=0.0\n        return error_rate\n\n    def show_index_report(self, verbose: bool=False, with_print:bool=True)-&gt;str:\n        \"\"\"\n        Displays a report on the indexing results of email mailboxes.\n\n        Args:\n            indexing_result (IndexingResult): The result of the indexing process containing detailed results.\n            verbose (bool): If True, displays detailed error and success messages.\n            with_print(bool): if True - actually print out the index report\n        Returns:\n            an indexing report message\n        \"\"\"\n        report=\"\"\n        if with_print:\n            print(self.msg)\n            report=self.msg\n        if verbose:\n            # Detailed error messages\n            if self.errors:\n                err_msg = \"Errors occurred during index creation:\\n\"\n                for path, error in self.errors.items():\n                    err_msg += f\"Error in {path}: {error}\\n\"\n                if with_print:\n                    print(err_msg, file=sys.stderr)\n                report+=\"\\n\"+err_msg\n\n            # Detailed success messages\n            if self.success:\n                success_msg = \"Index created successfully for:\\n\"\n                for path, count in self.success.items():\n                    success_msg += f\"{path}: {count} entries\\n\"\n                if with_print:\n                    print(success_msg)\n                report+=\"\\n\"+success_msg\n\n        # Summary message\n        total_errors = len(self.errors)\n        total_successes = sum(self.success.values())\n        average_success = (\n            (total_successes / len(self.success))\n            if self.success\n            else 0\n        )\n        error_rate = (\n            (total_errors / self.total_mailboxes) * 100\n            if self.total_mailboxes &gt; 0\n            else 0\n        )\n\n        marker = \"\u274c \" if total_errors &gt; 0 else \"\u2705\"\n        summary_msg = (\n            f\"Indexing completed: {marker}Total indexed messages: {total_successes}, \"\n            f\"Average messages per successful mailbox: {average_success:.2f}, \"\n            f\"{total_errors} mailboxes with errors ({error_rate:.2f}%).\"\n        )\n        msg_channel = sys.stderr if total_errors &gt; 0 else sys.stdout\n        if self.total_mailboxes &gt; 0:\n            print(summary_msg, file=msg_channel)\n            report+=\"\\n\"+summary_msg\n        return report\n\n    def get_update_lod(self):\n        \"\"\"\n        get a list of dict of update records\n        \"\"\"\n        update_lod = []\n        for i,mailbox in enumerate(self.mailboxes_to_update.values()):\n            mb_record=mailbox.as_view_record(index=i+1) \n            update_lod.append(mb_record)\n        return update_lod\n</code></pre>"},{"location":"#thunderbird.mail.IndexingState.error_rate","title":"<code>error_rate</code>  <code>property</code>","text":"<p>Calculate the error rate in percent</p>"},{"location":"#thunderbird.mail.IndexingState.get_update_lod","title":"<code>get_update_lod()</code>","text":"<p>get a list of dict of update records</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_update_lod(self):\n    \"\"\"\n    get a list of dict of update records\n    \"\"\"\n    update_lod = []\n    for i,mailbox in enumerate(self.mailboxes_to_update.values()):\n        mb_record=mailbox.as_view_record(index=i+1) \n        update_lod.append(mb_record)\n    return update_lod\n</code></pre>"},{"location":"#thunderbird.mail.IndexingState.show_index_report","title":"<code>show_index_report(verbose=False, with_print=True)</code>","text":"<p>Displays a report on the indexing results of email mailboxes.</p> <p>Parameters:</p> Name Type Description Default <code>indexing_result</code> <code>IndexingResult</code> <p>The result of the indexing process containing detailed results.</p> required <code>verbose</code> <code>bool</code> <p>If True, displays detailed error and success messages.</p> <code>False</code> <code>with_print(bool)</code> <p>if True - actually print out the index report</p> required <p>Returns:     an indexing report message</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def show_index_report(self, verbose: bool=False, with_print:bool=True)-&gt;str:\n    \"\"\"\n    Displays a report on the indexing results of email mailboxes.\n\n    Args:\n        indexing_result (IndexingResult): The result of the indexing process containing detailed results.\n        verbose (bool): If True, displays detailed error and success messages.\n        with_print(bool): if True - actually print out the index report\n    Returns:\n        an indexing report message\n    \"\"\"\n    report=\"\"\n    if with_print:\n        print(self.msg)\n        report=self.msg\n    if verbose:\n        # Detailed error messages\n        if self.errors:\n            err_msg = \"Errors occurred during index creation:\\n\"\n            for path, error in self.errors.items():\n                err_msg += f\"Error in {path}: {error}\\n\"\n            if with_print:\n                print(err_msg, file=sys.stderr)\n            report+=\"\\n\"+err_msg\n\n        # Detailed success messages\n        if self.success:\n            success_msg = \"Index created successfully for:\\n\"\n            for path, count in self.success.items():\n                success_msg += f\"{path}: {count} entries\\n\"\n            if with_print:\n                print(success_msg)\n            report+=\"\\n\"+success_msg\n\n    # Summary message\n    total_errors = len(self.errors)\n    total_successes = sum(self.success.values())\n    average_success = (\n        (total_successes / len(self.success))\n        if self.success\n        else 0\n    )\n    error_rate = (\n        (total_errors / self.total_mailboxes) * 100\n        if self.total_mailboxes &gt; 0\n        else 0\n    )\n\n    marker = \"\u274c \" if total_errors &gt; 0 else \"\u2705\"\n    summary_msg = (\n        f\"Indexing completed: {marker}Total indexed messages: {total_successes}, \"\n        f\"Average messages per successful mailbox: {average_success:.2f}, \"\n        f\"{total_errors} mailboxes with errors ({error_rate:.2f}%).\"\n    )\n    msg_channel = sys.stderr if total_errors &gt; 0 else sys.stdout\n    if self.total_mailboxes &gt; 0:\n        print(summary_msg, file=msg_channel)\n        report+=\"\\n\"+summary_msg\n    return report\n</code></pre>"},{"location":"#thunderbird.mail.Mail","title":"<code>Mail</code>","text":"<p>               Bases: <code>object</code></p> <p>a single mail</p> Source code in <code>thunderbird/mail.py</code> <pre><code>class Mail(object):\n    \"\"\"\n    a single mail\n    \"\"\"\n\n    def __init__(self, user, mailid, tb=None, debug=False, keySearch=True):\n        \"\"\"\n        Constructor\n\n        Args:\n            user(string): userid of the user\n            mailid(string): unique id of the mail\n            debug(bool): True if debugging should be activated\n            keySearch(bool): True if a slow keySearch should be tried when lookup fails\n        \"\"\"\n        self.debug = debug\n        self.user = user\n        if tb is None:\n            self.tb = Thunderbird.get(user)\n        else:\n            self.tb = tb\n        mailid = Mail.normalize_mailid(mailid)\n        self.mailid = mailid\n        self.keySearch = keySearch\n        self.rawMsg = None\n        self.msg = None\n        self.headers = {}\n        self.fromUrl = None\n        self.fromMailTo = None\n        self.toUrl = None\n        self.toMailTo = None\n        mail_record = self.search()\n        if mail_record is not None:\n            mail_lookup = MailLookup.from_mail_record(mail_record)\n            self.folder_path = mail_lookup.folder_path\n            folderPath = self.tb.local_folders + mail_lookup.folder_path\n            tb_mbox = ThunderbirdMailbox(self.tb, folderPath, debug=self.debug)\n            found=False\n            if mail_lookup.start_pos is not None and mail_lookup.stop_pos is not None:\n                self.msg = tb_mbox.get_message_by_pos(mail_lookup.start_pos, mail_lookup.stop_pos)\n                found = self.check_mailid()\n            if not found:\n                # Fallback to other methods if start_pos and stop_pos are not available\n                self.msg = tb_mbox.get_message_by_key(mail_lookup.message_index)\n            # if lookup fails we might loop thru\n            # all messages if this option is active ...\n            found = self.check_mailid()\n            if not found and self.keySearch:\n                self.msg = tb_mbox.search_message_by_key(self.mailid)\n            if self.msg is not None:\n                if self.check_mailid():\n                    self.extract_message()\n                else:\n                    self.msg = None\n            tb_mbox.close()\n\n    def check_mailid(self) -&gt; bool:\n        \"\"\"\n        check the mailid\n        \"\"\"\n        found = False\n        self.extract_headers()\n        # workaround awkward mail ID handling \n        # headers should be case insensitive but in reality they might be not\n        # if any message-id fits the self.mailid we'll consider the mail as found\n        id_headers = [\"Message-ID\",\"Message-Id\"]\n        for id_header in id_headers:\n            if id_header in self.headers:\n                header_id = self.headers[id_header]\n                header_id = self.normalize_mailid(header_id)\n                if header_id == self.mailid:\n                    found=True\n        return found\n\n    @classmethod\n    def get_iso_date(cls, msg) -&gt; Tuple[str, Optional[str], Optional[str]]:\n        \"\"\"\n        Extracts and formats the date from the email header in ISO format.\n\n        Args:\n            msg (Mail): The mail object from which to extract the date.\n\n        Returns:\n            Tuple[str, Optional[str], Optional[str]]: A tuple containing the msg_date, the formatted date in ISO format,\n            and an error message if the date cannot be extracted or parsed, otherwise None.\n        \"\"\"\n        date_parser = DateParser()\n        msg_date = msg.get(\"Date\", \"\")\n        iso_date = \"?\"\n        error_msg = None\n        if msg_date:\n            try:\n                iso_date = date_parser.parse_date(msg_date)\n            except Exception as e:\n                error_msg = f\"Error parsing date '{msg_date}': {e}\"\n        return msg_date, iso_date, error_msg\n\n    @classmethod\n    def normalize_mailid(cls, mail_id: str) -&gt; str:\n        \"\"\"\n        remove the surrounding &lt;&gt; of the given mail_id\n        \"\"\"\n        mail_id = re.sub(r\"\\&lt;(.*)\\&gt;\", r\"\\1\", mail_id)\n        return mail_id\n\n    def as_html_error_msg(self) -&gt; str:\n        \"\"\"\n        Generates an HTML formatted error message for the Mail instance.\n\n        This method should be called when a Mail object is requested but not found.\n        It uses the `normalize_mailid` method to format the mail ID in the error message.\n\n        Returns:\n            str: An HTML string representing the error message.\n        \"\"\"\n        normalized_mailid = Mail.normalize_mailid(self.mailid)\n        html_error_msg = f\"&lt;span style='color: red;'&gt;Mail with id {normalized_mailid} not found&lt;/span&gt;\"\n        return html_error_msg\n\n    def extract_headers(self):\n        \"\"\"\n        update the headers\n        \"\"\"\n        if not self.msg:\n            self.headers = {}\n        else:\n            for key in self.msg.keys():\n                # https://stackoverflow.com/a/21715870/1497139\n                self.headers[key] = str(make_header(decode_header(self.msg.get(key))))\n\n    def extract_message(self, lenient: bool = False) -&gt; None:\n        \"\"\"\n        Extracts the message body and headers from the email message.\n\n        This method decodes each part of the email message, handling different content types and charsets. It appends\n        the decoded text to the message object's text and HTML attributes.\n\n        Args:\n            lenient (bool): If True, the method will not raise an exception for decoding errors, and will instead skip the problematic parts.\n\n        \"\"\"\n        if len(self.headers) == 0:\n            self.extract_headers()\n        self.txtMsg = \"\"\n        self.html = \"\"\n        # https://stackoverflow.com/a/43833186/1497139\n        self.msgParts = []\n        # decode parts\n        # https://stackoverflow.com/questions/59554237/how-to-handle-all-charset-and-content-type-when-reading-email-from-imap-lib-in-p\n        # https://gist.github.com/miohtama/5389146\n        for part in self.msg.walk():\n            self.msgParts.append(part)\n            part.length = len(part._payload)\n            # each part is a either non-multipart, or another multipart message\n            # that contains further parts... Message is organized like a tree\n            contentType = part.get_content_type()\n            charset = part.get_content_charset()\n            if charset is None:\n                charset = \"utf-8\"\n            partname = part.get_param(\"name\")\n            part.filename = self.fixedPartName(\n                partname, contentType, len(self.msgParts)\n            )\n            if contentType == \"text/plain\" or contentType == \"text/html\":\n                part_str = part.get_payload(decode=1)\n                rawPart = self.try_decode(part_str, charset, lenient)\n                if rawPart is not None:\n                    if contentType == \"text/plain\":\n                        self.txtMsg += rawPart\n                    elif contentType == \"text/html\":\n                        self.html += rawPart\n            pass\n        self.handle_headers()\n\n    def try_decode(self, byte_str: bytes, charset: str, lenient: bool) -&gt; str:\n        \"\"\"\n        Attempts to decode a byte string using multiple charsets.\n\n        Tries to decode the byte string using a series of common charsets, returning the decoded string upon success.\n        If all attempts fail, it either raises a UnicodeDecodeError or returns None, based on the lenient flag.\n\n        Args:\n            byte_str (bytes): The byte string to be decoded.\n            charset (str): The initial charset to attempt decoding with.\n            lenient (bool): If True, suppresses UnicodeDecodeError and returns None for undecodable byte strings.\n\n        Returns:\n            str: The decoded string, or None if lenient is True and decoding fails.\n\n        Raises:\n            UnicodeDecodeError: If decoding fails and lenient is False.\n\n        \"\"\"\n        charsets_to_try = [charset, \"utf-8\", \"iso-8859-1\", \"ascii\"]\n        # Ensure no duplicate charsets in the list\n        unique_charsets = list(dict.fromkeys(charsets_to_try))\n\n        for encoding in unique_charsets:\n            try:\n                decoded = byte_str.decode(encoding)\n                return decoded\n            except UnicodeDecodeError:\n                continue\n\n        if not lenient:\n            raise UnicodeDecodeError(\n                f\"Failed to decode with charsets: {unique_charsets}\"\n            )\n        return None\n\n    def handle_headers(self):\n        # sort the headers\n        self.headers = OrderedDict(sorted(self.headers.items()))\n        if \"From\" in self.headers:\n            fromAdr = self.headers[\"From\"]\n            self.fromMailTo = f\"mailto:{fromAdr}\"\n            self.fromUrl = f\"&lt;a href='{self.fromMailTo}'&gt;{fromAdr}&lt;/a&gt;\"\n        if \"To\" in self.headers:\n            toAdr = self.headers[\"To\"]\n            self.toMailTo = f\"mailto:{toAdr}\"\n            self.toUrl = f\"&lt;a href='{self.toMailTo}'&gt;{toAdr}&lt;/a&gt;\"\n        pass\n\n    def search(self, use_index_db: bool = True) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Search for an email by its ID in the specified Thunderbird mailbox database.\n\n        This method allows searching either the gloda database or the index database based on the `use_index_db` parameter.\n        It returns a dictionary representing the found email or None if not found.\n\n        Args:\n            use_index_db (bool): If True, the search will be performed in the index database.\n                                 If False, the search will be performed in the gloda database (default).\n\n        Returns:\n            Optional[Dict[str, Any]]: A dictionary representing the found email, or None if not found.\n        \"\"\"\n        if self.debug:\n            print(f\"Searching for mail with id {self.mailid} for user {self.user}\")\n\n        if use_index_db and self.tb.index_db_exists():\n            # Query for the index database\n            query = \"\"\"SELECT * FROM mail_index \n                       WHERE message_id = ?\"\"\"\n            source = \"index_db\"\n            params = (f\"&lt;{self.mailid}&gt;\",)\n        else:\n            # Query for the gloda database\n            query = \"\"\"SELECT m.*, f.* \n                       FROM messages m JOIN\n                            folderLocations f ON m.folderId = f.id\n                       WHERE m.headerMessageID = (?)\"\"\"\n            source = \"gloda\"\n            params = (self.mailid,)\n\n        db = (\n            self.tb.index_db\n            if use_index_db and self.tb.index_db_exists()\n            else self.tb.sqlDB\n        )\n        maillookup = db.query(query, params)\n\n        if self.debug:\n            print(maillookup)\n\n        # Store the result in a variable before returning\n        mail_record = maillookup[0] if maillookup else None\n        if mail_record:\n            mail_record[\"source\"] = source\n            if not \"message_id\" in mail_record:\n                mail_record[\"message_id\"] = self.mailid\n        return mail_record\n\n    def fixedPartName(self, partname: str, contentType: str, partIndex: int):\n        \"\"\"\n        get a fixed version of the partname\n\n\n        Args:\n            partname(str): the name of the part\n            defaultName(str): the default name to use\n        \"\"\"\n\n        # avoid TypeError: expected string or bytes-like object\n        if partname:\n            if type(partname) is tuple:\n                _encoding, _unknown, partname = partname\n            filename = str(make_header(decode_header(partname)))\n        else:\n            ext = guess_extension(contentType.partition(\";\")[0].strip())\n            if ext is None:\n                ext = \".txt\"\n            filename = f\"part{partIndex}{ext}\"\n        filename = fix_text(filename)\n        return filename\n\n    def __str__(self):\n        text = f\"{self.user}/{self.mailid}\"\n        return text\n\n    def getHeader(self, headerName: str):\n        \"\"\"\n        get the header with the given name\n\n        Args:\n            headerName(str): the name of the header\n\n        Returns:\n            str: the header value\n        \"\"\"\n        if headerName in self.headers:\n            headerValue = self.headers[headerName]\n        else:\n            headerValue = \"?\"\n        return headerValue\n\n    def asWikiMarkup(self) -&gt; str:\n        \"\"\"\n        convert me to wiki markup in Wikison notation\n\n        Returns:\n            str: a http://wiki.bitplan.com/index.php/WikiSon notation\n        \"\"\"\n        if len(self.headers) == 0:\n            self.extract_headers()\n        _msg_date, iso_date, _error_msg = Mail.get_iso_date(self.msg)\n        wikison = f\"\"\"{{{{mail\n|user={self.user}\n|id={self.mailid}\n|from={self.getHeader('From')}\n|to={self.getHeader('To')}\n|subject={self.getHeader('Subject')}\n|date={iso_date}\n}}}}\"\"\"\n        return wikison\n\n    def table_line(self, key, value):\n        \"\"\"Generate a table row with a key and value.\"\"\"\n        return f\"&lt;tr&gt;&lt;th&gt;{key}:&lt;/th&gt;&lt;td&gt;{value}&lt;/td&gt;&lt;tr&gt;\"\n\n    def mail_part_row(self, loop_index: int, part):\n        \"\"\"Generate a table row for a mail part.\"\"\"\n        # Check if loop_index is 0 to add a header\n        header = \"\"\n        if self.mailid:\n            mailid = self.mailid.replace(\"&gt;\", \"\").replace(\"&lt;\", \"\")\n        else:\n            mailid = \"unknown-mailid\"\n        if loop_index == 0:\n            header = \"&lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Content Type&lt;/th&gt;&lt;th&gt;Charset&lt;/th&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;th style='text-align:right'&gt;Length&lt;/th&gt;&lt;/tr&gt;\"\n        link = Link.create(f\"/part/{self.user}/{mailid}/{loop_index}\", part.filename)\n        # Generate the row for the current part\n        row = f\"&lt;tr&gt;&lt;th&gt;{loop_index+1}:&lt;/th&gt;&lt;td&gt;{part.get_content_type()}&lt;/td&gt;&lt;td&gt;{part.get_content_charset()}&lt;/td&gt;&lt;td&gt;{link}&lt;/a&gt;&lt;/td&gt;&lt;td style='text-align:right'&gt;{part.length}&lt;/td&gt;&lt;tr&gt;\"\n        return header + row\n\n    def as_html_section(self, section_name):\n        \"\"\"\n        convert my content to the given html section\n\n        Args:\n            section_name(str): the name of the section to create\n        \"\"\"\n        html_parts = []\n        # Start building the HTML string\n        table_sections = [\"info\", \"parts\", \"headers\"]\n        if section_name in table_sections:\n            html_parts.append(\"&lt;hr&gt;\")\n            html_parts.append(f\"&lt;table id='{section_name}Table'&gt;\")\n        if section_name == \"title\":\n            if self.mailid:\n                html_parts.append(f\"&lt;h2&gt;{self.mailid}&lt;/h2&gt;\")\n        elif section_name == \"wiki\":\n            html_parts.append(f\"&lt;hr&gt;&lt;pre&gt;{self.asWikiMarkup()}&lt;/pre&gt;\")\n        elif section_name == \"info\":\n            html_parts.append(self.table_line(\"User\", self.user))\n            html_parts.append(self.table_line(\"Folder\", self.folder_path))\n            html_parts.append(self.table_line(\"From\", self.fromUrl))\n            html_parts.append(self.table_line(\"To\", self.toUrl))\n            html_parts.append(self.table_line(\"Date\", self.getHeader(\"Date\")))\n            html_parts.append(self.table_line(\"Subject\", self.getHeader(\"Subject\")))\n            html_parts.append(\n                self.table_line(\"Message-ID\", self.getHeader(\"Message-ID\"))\n            )\n        elif section_name == \"headers\":\n            for key, value in self.headers.items():\n                html_parts.append(self.table_line(key, value))\n        # Closing t\n        elif section_name == \"parts\":\n            for index, part in enumerate(self.msgParts):\n                html_parts.append(self.mail_part_row(index, part))\n        elif section_name == \"text\":\n            # Add raw message parts if necessary\n            html_parts.append(f\"&lt;hr&gt;&lt;p id='txtMsg'&gt;{self.txtMsg}&lt;/p&gt;\")\n        elif section_name == \"html\":\n            html_parts.append(f\"&lt;hr&gt;&lt;div id='htmlMsg'&gt;{self.html}&lt;/div&gt;\")\n        if section_name in table_sections:\n            # Closing tables\n            html_parts.append(\"&lt;/table&gt;\")\n        markup = \"\".join(html_parts)\n        return markup\n\n    def as_html(self):\n        \"\"\"Generate the HTML representation of the mail.\"\"\"\n        html = \"\"\n        for section_name in [\"title\", \"info\", \"parts\", \"text\", \"html\"]:\n            html += self.as_html_section(section_name)\n        return html\n\n    def part_as_fileresponse(\n        self, part_index: int, attachments_path: str = None\n    ) -&gt; Any:\n        \"\"\"\n        Return the specified part of a message as a FileResponse.\n\n        Args:\n            part_index (int): The index of the part to be returned.\n\n        Returns:\n            FileResponse: A FileResponse object representing the specified part.\n\n        Raises:\n            IndexError: If the part_index is out of range of the message parts.\n            ValueError: If the part content is not decodable.\n\n        Note:\n            The method assumes that self.msgParts is a list-like container holding the message parts.\n            Since FastAPI's FileResponse is designed to work with file paths, this function writes the content to a temporary file.\n        \"\"\"\n        # Check if part_index is within the range of msgParts\n        if not 0 &lt;= part_index &lt; len(self.msgParts):\n            raise IndexError(\"part_index out of range.\")\n\n        # Get the specific part from the msgParts\n        part = self.msgParts[part_index]\n\n        # Get the content of the part, decode if necessary\n        try:\n            content = part.get_payload(decode=True)\n        except:\n            raise ValueError(\"Unable to decode part content.\")\n\n        # Write content to a temporary file\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            temp_file_name = temp_file.name\n            temp_file.write(content)\n\n        # Create and return a FileResponse object\n        file_response = FileResponse(\n            path=temp_file_name, filename=part.get_filename() or \"file\"\n        )\n\n        # Delete the temporary file after sending the response\n        async def on_send_response() -&gt; None:\n            os.unlink(temp_file_name)\n\n        file_response.background = on_send_response\n\n        # response=StreamingResponse(io.BytesIO(content),media_type=)\n        return file_response\n\n    @staticmethod\n    def toSbdFolder(folderURI):\n        \"\"\"\n        get the SBD folder for the given folderURI as a tuple\n\n        Args:\n            folderURI(str): the folder uri\n        Returns:\n            sbdFolder(str): the prefix\n            folder(str): the local path\n        \"\"\"\n        folder = folderURI.replace(\"mailbox://nobody@\", \"\")\n        # https://stackoverflow.com/a/14007559/1497139\n        parts = folder.split(\"/\")\n        sbdFolder = \"/Mail/\"\n        folder = \"\"\n        for i, part in enumerate(parts):\n            if i == 0:  # e.g. \"Local Folders\" ...\n                sbdFolder += f\"{part}/\"\n            elif i &lt; len(parts) - 1:\n                sbdFolder += f\"{part}.sbd/\"\n                folder += f\"{part}/\"\n            else:\n                sbdFolder += f\"{part}\"\n                folder += f\"{part}\"\n        return sbdFolder, folder\n\n    @staticmethod\n    def create_message(frm, to, content, headers=None):\n        if not headers:\n            headers = {}\n        m = mailbox.Message()\n        m[\"from\"] = frm\n        m[\"to\"] = to\n        for h, v in headers.items():\n            m[h] = v\n        m.set_payload(content)\n        return m\n</code></pre>"},{"location":"#thunderbird.mail.Mail.__init__","title":"<code>__init__(user, mailid, tb=None, debug=False, keySearch=True)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>user(string)</code> <p>userid of the user</p> required <code>mailid(string)</code> <p>unique id of the mail</p> required <code>debug(bool)</code> <p>True if debugging should be activated</p> required <code>keySearch(bool)</code> <p>True if a slow keySearch should be tried when lookup fails</p> required Source code in <code>thunderbird/mail.py</code> <pre><code>def __init__(self, user, mailid, tb=None, debug=False, keySearch=True):\n    \"\"\"\n    Constructor\n\n    Args:\n        user(string): userid of the user\n        mailid(string): unique id of the mail\n        debug(bool): True if debugging should be activated\n        keySearch(bool): True if a slow keySearch should be tried when lookup fails\n    \"\"\"\n    self.debug = debug\n    self.user = user\n    if tb is None:\n        self.tb = Thunderbird.get(user)\n    else:\n        self.tb = tb\n    mailid = Mail.normalize_mailid(mailid)\n    self.mailid = mailid\n    self.keySearch = keySearch\n    self.rawMsg = None\n    self.msg = None\n    self.headers = {}\n    self.fromUrl = None\n    self.fromMailTo = None\n    self.toUrl = None\n    self.toMailTo = None\n    mail_record = self.search()\n    if mail_record is not None:\n        mail_lookup = MailLookup.from_mail_record(mail_record)\n        self.folder_path = mail_lookup.folder_path\n        folderPath = self.tb.local_folders + mail_lookup.folder_path\n        tb_mbox = ThunderbirdMailbox(self.tb, folderPath, debug=self.debug)\n        found=False\n        if mail_lookup.start_pos is not None and mail_lookup.stop_pos is not None:\n            self.msg = tb_mbox.get_message_by_pos(mail_lookup.start_pos, mail_lookup.stop_pos)\n            found = self.check_mailid()\n        if not found:\n            # Fallback to other methods if start_pos and stop_pos are not available\n            self.msg = tb_mbox.get_message_by_key(mail_lookup.message_index)\n        # if lookup fails we might loop thru\n        # all messages if this option is active ...\n        found = self.check_mailid()\n        if not found and self.keySearch:\n            self.msg = tb_mbox.search_message_by_key(self.mailid)\n        if self.msg is not None:\n            if self.check_mailid():\n                self.extract_message()\n            else:\n                self.msg = None\n        tb_mbox.close()\n</code></pre>"},{"location":"#thunderbird.mail.Mail.asWikiMarkup","title":"<code>asWikiMarkup()</code>","text":"<p>convert me to wiki markup in Wikison notation</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a http://wiki.bitplan.com/index.php/WikiSon notation</p> Source code in <code>thunderbird/mail.py</code> <pre><code>    def asWikiMarkup(self) -&gt; str:\n        \"\"\"\n        convert me to wiki markup in Wikison notation\n\n        Returns:\n            str: a http://wiki.bitplan.com/index.php/WikiSon notation\n        \"\"\"\n        if len(self.headers) == 0:\n            self.extract_headers()\n        _msg_date, iso_date, _error_msg = Mail.get_iso_date(self.msg)\n        wikison = f\"\"\"{{{{mail\n|user={self.user}\n|id={self.mailid}\n|from={self.getHeader('From')}\n|to={self.getHeader('To')}\n|subject={self.getHeader('Subject')}\n|date={iso_date}\n}}}}\"\"\"\n        return wikison\n</code></pre>"},{"location":"#thunderbird.mail.Mail.as_html","title":"<code>as_html()</code>","text":"<p>Generate the HTML representation of the mail.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def as_html(self):\n    \"\"\"Generate the HTML representation of the mail.\"\"\"\n    html = \"\"\n    for section_name in [\"title\", \"info\", \"parts\", \"text\", \"html\"]:\n        html += self.as_html_section(section_name)\n    return html\n</code></pre>"},{"location":"#thunderbird.mail.Mail.as_html_error_msg","title":"<code>as_html_error_msg()</code>","text":"<p>Generates an HTML formatted error message for the Mail instance.</p> <p>This method should be called when a Mail object is requested but not found. It uses the <code>normalize_mailid</code> method to format the mail ID in the error message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>An HTML string representing the error message.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def as_html_error_msg(self) -&gt; str:\n    \"\"\"\n    Generates an HTML formatted error message for the Mail instance.\n\n    This method should be called when a Mail object is requested but not found.\n    It uses the `normalize_mailid` method to format the mail ID in the error message.\n\n    Returns:\n        str: An HTML string representing the error message.\n    \"\"\"\n    normalized_mailid = Mail.normalize_mailid(self.mailid)\n    html_error_msg = f\"&lt;span style='color: red;'&gt;Mail with id {normalized_mailid} not found&lt;/span&gt;\"\n    return html_error_msg\n</code></pre>"},{"location":"#thunderbird.mail.Mail.as_html_section","title":"<code>as_html_section(section_name)</code>","text":"<p>convert my content to the given html section</p> <p>Parameters:</p> Name Type Description Default <code>section_name(str)</code> <p>the name of the section to create</p> required Source code in <code>thunderbird/mail.py</code> <pre><code>def as_html_section(self, section_name):\n    \"\"\"\n    convert my content to the given html section\n\n    Args:\n        section_name(str): the name of the section to create\n    \"\"\"\n    html_parts = []\n    # Start building the HTML string\n    table_sections = [\"info\", \"parts\", \"headers\"]\n    if section_name in table_sections:\n        html_parts.append(\"&lt;hr&gt;\")\n        html_parts.append(f\"&lt;table id='{section_name}Table'&gt;\")\n    if section_name == \"title\":\n        if self.mailid:\n            html_parts.append(f\"&lt;h2&gt;{self.mailid}&lt;/h2&gt;\")\n    elif section_name == \"wiki\":\n        html_parts.append(f\"&lt;hr&gt;&lt;pre&gt;{self.asWikiMarkup()}&lt;/pre&gt;\")\n    elif section_name == \"info\":\n        html_parts.append(self.table_line(\"User\", self.user))\n        html_parts.append(self.table_line(\"Folder\", self.folder_path))\n        html_parts.append(self.table_line(\"From\", self.fromUrl))\n        html_parts.append(self.table_line(\"To\", self.toUrl))\n        html_parts.append(self.table_line(\"Date\", self.getHeader(\"Date\")))\n        html_parts.append(self.table_line(\"Subject\", self.getHeader(\"Subject\")))\n        html_parts.append(\n            self.table_line(\"Message-ID\", self.getHeader(\"Message-ID\"))\n        )\n    elif section_name == \"headers\":\n        for key, value in self.headers.items():\n            html_parts.append(self.table_line(key, value))\n    # Closing t\n    elif section_name == \"parts\":\n        for index, part in enumerate(self.msgParts):\n            html_parts.append(self.mail_part_row(index, part))\n    elif section_name == \"text\":\n        # Add raw message parts if necessary\n        html_parts.append(f\"&lt;hr&gt;&lt;p id='txtMsg'&gt;{self.txtMsg}&lt;/p&gt;\")\n    elif section_name == \"html\":\n        html_parts.append(f\"&lt;hr&gt;&lt;div id='htmlMsg'&gt;{self.html}&lt;/div&gt;\")\n    if section_name in table_sections:\n        # Closing tables\n        html_parts.append(\"&lt;/table&gt;\")\n    markup = \"\".join(html_parts)\n    return markup\n</code></pre>"},{"location":"#thunderbird.mail.Mail.check_mailid","title":"<code>check_mailid()</code>","text":"<p>check the mailid</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def check_mailid(self) -&gt; bool:\n    \"\"\"\n    check the mailid\n    \"\"\"\n    found = False\n    self.extract_headers()\n    # workaround awkward mail ID handling \n    # headers should be case insensitive but in reality they might be not\n    # if any message-id fits the self.mailid we'll consider the mail as found\n    id_headers = [\"Message-ID\",\"Message-Id\"]\n    for id_header in id_headers:\n        if id_header in self.headers:\n            header_id = self.headers[id_header]\n            header_id = self.normalize_mailid(header_id)\n            if header_id == self.mailid:\n                found=True\n    return found\n</code></pre>"},{"location":"#thunderbird.mail.Mail.extract_headers","title":"<code>extract_headers()</code>","text":"<p>update the headers</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def extract_headers(self):\n    \"\"\"\n    update the headers\n    \"\"\"\n    if not self.msg:\n        self.headers = {}\n    else:\n        for key in self.msg.keys():\n            # https://stackoverflow.com/a/21715870/1497139\n            self.headers[key] = str(make_header(decode_header(self.msg.get(key))))\n</code></pre>"},{"location":"#thunderbird.mail.Mail.extract_message","title":"<code>extract_message(lenient=False)</code>","text":"<p>Extracts the message body and headers from the email message.</p> <p>This method decodes each part of the email message, handling different content types and charsets. It appends the decoded text to the message object's text and HTML attributes.</p> <p>Parameters:</p> Name Type Description Default <code>lenient</code> <code>bool</code> <p>If True, the method will not raise an exception for decoding errors, and will instead skip the problematic parts.</p> <code>False</code> Source code in <code>thunderbird/mail.py</code> <pre><code>def extract_message(self, lenient: bool = False) -&gt; None:\n    \"\"\"\n    Extracts the message body and headers from the email message.\n\n    This method decodes each part of the email message, handling different content types and charsets. It appends\n    the decoded text to the message object's text and HTML attributes.\n\n    Args:\n        lenient (bool): If True, the method will not raise an exception for decoding errors, and will instead skip the problematic parts.\n\n    \"\"\"\n    if len(self.headers) == 0:\n        self.extract_headers()\n    self.txtMsg = \"\"\n    self.html = \"\"\n    # https://stackoverflow.com/a/43833186/1497139\n    self.msgParts = []\n    # decode parts\n    # https://stackoverflow.com/questions/59554237/how-to-handle-all-charset-and-content-type-when-reading-email-from-imap-lib-in-p\n    # https://gist.github.com/miohtama/5389146\n    for part in self.msg.walk():\n        self.msgParts.append(part)\n        part.length = len(part._payload)\n        # each part is a either non-multipart, or another multipart message\n        # that contains further parts... Message is organized like a tree\n        contentType = part.get_content_type()\n        charset = part.get_content_charset()\n        if charset is None:\n            charset = \"utf-8\"\n        partname = part.get_param(\"name\")\n        part.filename = self.fixedPartName(\n            partname, contentType, len(self.msgParts)\n        )\n        if contentType == \"text/plain\" or contentType == \"text/html\":\n            part_str = part.get_payload(decode=1)\n            rawPart = self.try_decode(part_str, charset, lenient)\n            if rawPart is not None:\n                if contentType == \"text/plain\":\n                    self.txtMsg += rawPart\n                elif contentType == \"text/html\":\n                    self.html += rawPart\n        pass\n    self.handle_headers()\n</code></pre>"},{"location":"#thunderbird.mail.Mail.fixedPartName","title":"<code>fixedPartName(partname, contentType, partIndex)</code>","text":"<p>get a fixed version of the partname</p> <p>Parameters:</p> Name Type Description Default <code>partname(str)</code> <p>the name of the part</p> required <code>defaultName(str)</code> <p>the default name to use</p> required Source code in <code>thunderbird/mail.py</code> <pre><code>def fixedPartName(self, partname: str, contentType: str, partIndex: int):\n    \"\"\"\n    get a fixed version of the partname\n\n\n    Args:\n        partname(str): the name of the part\n        defaultName(str): the default name to use\n    \"\"\"\n\n    # avoid TypeError: expected string or bytes-like object\n    if partname:\n        if type(partname) is tuple:\n            _encoding, _unknown, partname = partname\n        filename = str(make_header(decode_header(partname)))\n    else:\n        ext = guess_extension(contentType.partition(\";\")[0].strip())\n        if ext is None:\n            ext = \".txt\"\n        filename = f\"part{partIndex}{ext}\"\n    filename = fix_text(filename)\n    return filename\n</code></pre>"},{"location":"#thunderbird.mail.Mail.getHeader","title":"<code>getHeader(headerName)</code>","text":"<p>get the header with the given name</p> <p>Parameters:</p> Name Type Description Default <code>headerName(str)</code> <p>the name of the header</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the header value</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def getHeader(self, headerName: str):\n    \"\"\"\n    get the header with the given name\n\n    Args:\n        headerName(str): the name of the header\n\n    Returns:\n        str: the header value\n    \"\"\"\n    if headerName in self.headers:\n        headerValue = self.headers[headerName]\n    else:\n        headerValue = \"?\"\n    return headerValue\n</code></pre>"},{"location":"#thunderbird.mail.Mail.get_iso_date","title":"<code>get_iso_date(msg)</code>  <code>classmethod</code>","text":"<p>Extracts and formats the date from the email header in ISO format.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Mail</code> <p>The mail object from which to extract the date.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Tuple[str, Optional[str], Optional[str]]: A tuple containing the msg_date, the formatted date in ISO format,</p> <code>Optional[str]</code> <p>and an error message if the date cannot be extracted or parsed, otherwise None.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef get_iso_date(cls, msg) -&gt; Tuple[str, Optional[str], Optional[str]]:\n    \"\"\"\n    Extracts and formats the date from the email header in ISO format.\n\n    Args:\n        msg (Mail): The mail object from which to extract the date.\n\n    Returns:\n        Tuple[str, Optional[str], Optional[str]]: A tuple containing the msg_date, the formatted date in ISO format,\n        and an error message if the date cannot be extracted or parsed, otherwise None.\n    \"\"\"\n    date_parser = DateParser()\n    msg_date = msg.get(\"Date\", \"\")\n    iso_date = \"?\"\n    error_msg = None\n    if msg_date:\n        try:\n            iso_date = date_parser.parse_date(msg_date)\n        except Exception as e:\n            error_msg = f\"Error parsing date '{msg_date}': {e}\"\n    return msg_date, iso_date, error_msg\n</code></pre>"},{"location":"#thunderbird.mail.Mail.mail_part_row","title":"<code>mail_part_row(loop_index, part)</code>","text":"<p>Generate a table row for a mail part.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def mail_part_row(self, loop_index: int, part):\n    \"\"\"Generate a table row for a mail part.\"\"\"\n    # Check if loop_index is 0 to add a header\n    header = \"\"\n    if self.mailid:\n        mailid = self.mailid.replace(\"&gt;\", \"\").replace(\"&lt;\", \"\")\n    else:\n        mailid = \"unknown-mailid\"\n    if loop_index == 0:\n        header = \"&lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Content Type&lt;/th&gt;&lt;th&gt;Charset&lt;/th&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;th style='text-align:right'&gt;Length&lt;/th&gt;&lt;/tr&gt;\"\n    link = Link.create(f\"/part/{self.user}/{mailid}/{loop_index}\", part.filename)\n    # Generate the row for the current part\n    row = f\"&lt;tr&gt;&lt;th&gt;{loop_index+1}:&lt;/th&gt;&lt;td&gt;{part.get_content_type()}&lt;/td&gt;&lt;td&gt;{part.get_content_charset()}&lt;/td&gt;&lt;td&gt;{link}&lt;/a&gt;&lt;/td&gt;&lt;td style='text-align:right'&gt;{part.length}&lt;/td&gt;&lt;tr&gt;\"\n    return header + row\n</code></pre>"},{"location":"#thunderbird.mail.Mail.normalize_mailid","title":"<code>normalize_mailid(mail_id)</code>  <code>classmethod</code>","text":"<p>remove the surrounding &lt;&gt; of the given mail_id</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef normalize_mailid(cls, mail_id: str) -&gt; str:\n    \"\"\"\n    remove the surrounding &lt;&gt; of the given mail_id\n    \"\"\"\n    mail_id = re.sub(r\"\\&lt;(.*)\\&gt;\", r\"\\1\", mail_id)\n    return mail_id\n</code></pre>"},{"location":"#thunderbird.mail.Mail.part_as_fileresponse","title":"<code>part_as_fileresponse(part_index, attachments_path=None)</code>","text":"<p>Return the specified part of a message as a FileResponse.</p> <p>Parameters:</p> Name Type Description Default <code>part_index</code> <code>int</code> <p>The index of the part to be returned.</p> required <p>Returns:</p> Name Type Description <code>FileResponse</code> <code>Any</code> <p>A FileResponse object representing the specified part.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the part_index is out of range of the message parts.</p> <code>ValueError</code> <p>If the part content is not decodable.</p> Note <p>The method assumes that self.msgParts is a list-like container holding the message parts. Since FastAPI's FileResponse is designed to work with file paths, this function writes the content to a temporary file.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def part_as_fileresponse(\n    self, part_index: int, attachments_path: str = None\n) -&gt; Any:\n    \"\"\"\n    Return the specified part of a message as a FileResponse.\n\n    Args:\n        part_index (int): The index of the part to be returned.\n\n    Returns:\n        FileResponse: A FileResponse object representing the specified part.\n\n    Raises:\n        IndexError: If the part_index is out of range of the message parts.\n        ValueError: If the part content is not decodable.\n\n    Note:\n        The method assumes that self.msgParts is a list-like container holding the message parts.\n        Since FastAPI's FileResponse is designed to work with file paths, this function writes the content to a temporary file.\n    \"\"\"\n    # Check if part_index is within the range of msgParts\n    if not 0 &lt;= part_index &lt; len(self.msgParts):\n        raise IndexError(\"part_index out of range.\")\n\n    # Get the specific part from the msgParts\n    part = self.msgParts[part_index]\n\n    # Get the content of the part, decode if necessary\n    try:\n        content = part.get_payload(decode=True)\n    except:\n        raise ValueError(\"Unable to decode part content.\")\n\n    # Write content to a temporary file\n    with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n        temp_file_name = temp_file.name\n        temp_file.write(content)\n\n    # Create and return a FileResponse object\n    file_response = FileResponse(\n        path=temp_file_name, filename=part.get_filename() or \"file\"\n    )\n\n    # Delete the temporary file after sending the response\n    async def on_send_response() -&gt; None:\n        os.unlink(temp_file_name)\n\n    file_response.background = on_send_response\n\n    # response=StreamingResponse(io.BytesIO(content),media_type=)\n    return file_response\n</code></pre>"},{"location":"#thunderbird.mail.Mail.search","title":"<code>search(use_index_db=True)</code>","text":"<p>Search for an email by its ID in the specified Thunderbird mailbox database.</p> <p>This method allows searching either the gloda database or the index database based on the <code>use_index_db</code> parameter. It returns a dictionary representing the found email or None if not found.</p> <p>Parameters:</p> Name Type Description Default <code>use_index_db</code> <code>bool</code> <p>If True, the search will be performed in the index database.                  If False, the search will be performed in the gloda database (default).</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: A dictionary representing the found email, or None if not found.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def search(self, use_index_db: bool = True) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Search for an email by its ID in the specified Thunderbird mailbox database.\n\n    This method allows searching either the gloda database or the index database based on the `use_index_db` parameter.\n    It returns a dictionary representing the found email or None if not found.\n\n    Args:\n        use_index_db (bool): If True, the search will be performed in the index database.\n                             If False, the search will be performed in the gloda database (default).\n\n    Returns:\n        Optional[Dict[str, Any]]: A dictionary representing the found email, or None if not found.\n    \"\"\"\n    if self.debug:\n        print(f\"Searching for mail with id {self.mailid} for user {self.user}\")\n\n    if use_index_db and self.tb.index_db_exists():\n        # Query for the index database\n        query = \"\"\"SELECT * FROM mail_index \n                   WHERE message_id = ?\"\"\"\n        source = \"index_db\"\n        params = (f\"&lt;{self.mailid}&gt;\",)\n    else:\n        # Query for the gloda database\n        query = \"\"\"SELECT m.*, f.* \n                   FROM messages m JOIN\n                        folderLocations f ON m.folderId = f.id\n                   WHERE m.headerMessageID = (?)\"\"\"\n        source = \"gloda\"\n        params = (self.mailid,)\n\n    db = (\n        self.tb.index_db\n        if use_index_db and self.tb.index_db_exists()\n        else self.tb.sqlDB\n    )\n    maillookup = db.query(query, params)\n\n    if self.debug:\n        print(maillookup)\n\n    # Store the result in a variable before returning\n    mail_record = maillookup[0] if maillookup else None\n    if mail_record:\n        mail_record[\"source\"] = source\n        if not \"message_id\" in mail_record:\n            mail_record[\"message_id\"] = self.mailid\n    return mail_record\n</code></pre>"},{"location":"#thunderbird.mail.Mail.table_line","title":"<code>table_line(key, value)</code>","text":"<p>Generate a table row with a key and value.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def table_line(self, key, value):\n    \"\"\"Generate a table row with a key and value.\"\"\"\n    return f\"&lt;tr&gt;&lt;th&gt;{key}:&lt;/th&gt;&lt;td&gt;{value}&lt;/td&gt;&lt;tr&gt;\"\n</code></pre>"},{"location":"#thunderbird.mail.Mail.toSbdFolder","title":"<code>toSbdFolder(folderURI)</code>  <code>staticmethod</code>","text":"<p>get the SBD folder for the given folderURI as a tuple</p> <p>Parameters:</p> Name Type Description Default <code>folderURI(str)</code> <p>the folder uri</p> required <p>Returns:     sbdFolder(str): the prefix     folder(str): the local path</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@staticmethod\ndef toSbdFolder(folderURI):\n    \"\"\"\n    get the SBD folder for the given folderURI as a tuple\n\n    Args:\n        folderURI(str): the folder uri\n    Returns:\n        sbdFolder(str): the prefix\n        folder(str): the local path\n    \"\"\"\n    folder = folderURI.replace(\"mailbox://nobody@\", \"\")\n    # https://stackoverflow.com/a/14007559/1497139\n    parts = folder.split(\"/\")\n    sbdFolder = \"/Mail/\"\n    folder = \"\"\n    for i, part in enumerate(parts):\n        if i == 0:  # e.g. \"Local Folders\" ...\n            sbdFolder += f\"{part}/\"\n        elif i &lt; len(parts) - 1:\n            sbdFolder += f\"{part}.sbd/\"\n            folder += f\"{part}/\"\n        else:\n            sbdFolder += f\"{part}\"\n            folder += f\"{part}\"\n    return sbdFolder, folder\n</code></pre>"},{"location":"#thunderbird.mail.Mail.try_decode","title":"<code>try_decode(byte_str, charset, lenient)</code>","text":"<p>Attempts to decode a byte string using multiple charsets.</p> <p>Tries to decode the byte string using a series of common charsets, returning the decoded string upon success. If all attempts fail, it either raises a UnicodeDecodeError or returns None, based on the lenient flag.</p> <p>Parameters:</p> Name Type Description Default <code>byte_str</code> <code>bytes</code> <p>The byte string to be decoded.</p> required <code>charset</code> <code>str</code> <p>The initial charset to attempt decoding with.</p> required <code>lenient</code> <code>bool</code> <p>If True, suppresses UnicodeDecodeError and returns None for undecodable byte strings.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The decoded string, or None if lenient is True and decoding fails.</p> <p>Raises:</p> Type Description <code>UnicodeDecodeError</code> <p>If decoding fails and lenient is False.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def try_decode(self, byte_str: bytes, charset: str, lenient: bool) -&gt; str:\n    \"\"\"\n    Attempts to decode a byte string using multiple charsets.\n\n    Tries to decode the byte string using a series of common charsets, returning the decoded string upon success.\n    If all attempts fail, it either raises a UnicodeDecodeError or returns None, based on the lenient flag.\n\n    Args:\n        byte_str (bytes): The byte string to be decoded.\n        charset (str): The initial charset to attempt decoding with.\n        lenient (bool): If True, suppresses UnicodeDecodeError and returns None for undecodable byte strings.\n\n    Returns:\n        str: The decoded string, or None if lenient is True and decoding fails.\n\n    Raises:\n        UnicodeDecodeError: If decoding fails and lenient is False.\n\n    \"\"\"\n    charsets_to_try = [charset, \"utf-8\", \"iso-8859-1\", \"ascii\"]\n    # Ensure no duplicate charsets in the list\n    unique_charsets = list(dict.fromkeys(charsets_to_try))\n\n    for encoding in unique_charsets:\n        try:\n            decoded = byte_str.decode(encoding)\n            return decoded\n        except UnicodeDecodeError:\n            continue\n\n    if not lenient:\n        raise UnicodeDecodeError(\n            f\"Failed to decode with charsets: {unique_charsets}\"\n        )\n    return None\n</code></pre>"},{"location":"#thunderbird.mail.MailArchive","title":"<code>MailArchive</code>  <code>dataclass</code>","text":"<p>Represents a single mail archive for a user.</p> <p>Attributes:</p> Name Type Description <code>user</code> <code>str</code> <p>The user to whom the mail archive belongs.</p> <code>gloda_db_path</code> <code>str</code> <p>The file path of the mailbox global database (sqlite).</p> <code>index_db_path</code> <code>str</code> <p>The file path of the mailbox index database (sqlite).</p> <code>profile</code> <code>str</code> <p>the Thunderbird profile directory of this mailbox.</p> <code>gloda_db_update_time</code> <code>str</code> <p>The last update time of the global database, default is None.</p> <code>index_db_update_time</code> <code>str</code> <p>The last update time of the index database, default is None.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@dataclass\nclass MailArchive:\n    \"\"\"\n    Represents a single mail archive for a user.\n\n    Attributes:\n        user (str): The user to whom the mail archive belongs.\n        gloda_db_path (str): The file path of the mailbox global database (sqlite).\n        index_db_path (str, optional): The file path of the mailbox index database (sqlite).\n        profile (str, optional): the Thunderbird profile directory of this mailbox.\n        gloda_db_update_time (str, optional): The last update time of the global database, default is None.\n        index_db_update_time (str, optional): The last update time of the index database, default is None.\n    \"\"\"\n\n    user: str\n    gloda_db_path: str\n    index_db_path: str = None\n    profile: str = None\n    gloda_db_update_time: str = None\n    index_db_update_time: str = None\n\n    def index_db_exists(self) -&gt; bool:\n        \"\"\"Checks if the index database file exists and is not empty.\n\n        Returns:\n            bool: True if the index database file exists and has a size greater than zero, otherwise False.\n        \"\"\"\n        # Check if the index database file exists and its size is greater than zero bytes\n        result: bool = (\n            os.path.isfile(self.index_db_path)\n            and os.path.getsize(self.index_db_path) &gt; 0\n        )\n        return result\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization processing to set the database update times.\n        \"\"\"\n        self.gloda_db_update_time = self._get_file_update_time(self.gloda_db_path)\n        self.index_db_path = os.path.join(\n            os.path.dirname(self.gloda_db_path), \"index_db.sqlite\"\n        )\n        if self.index_db_exists():\n            self.index_db_update_time = self._get_file_update_time(self.index_db_path)\n\n    def _get_file_update_time(self, file_path: str) -&gt; str:\n        \"\"\"\n        Gets the formatted last update time of the specified file.\n\n        Args:\n            file_path (str): The  path of the file for which to get the update time.\n\n        Returns:\n            str: The formatted last update time.\n        \"\"\"\n        timestamp = os.path.getmtime(file_path)\n        return datetime.fromtimestamp(timestamp).strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def to_dict(self, index: int = None) -&gt; Dict[str, str]:\n        \"\"\"\n        Converts the mail archive data to a dictionary, including the update times for both databases.\n\n        Args:\n            index (int, optional): An optional index to be added to the dictionary.\n\n        Returns:\n            Dict[str, str]: The dictionary representation of the mail archive.\n        \"\"\"\n        profile_shortened = os.path.basename(self.profile) if self.profile else None\n        ps_parts = (\n            profile_shortened.split(\".\")\n            if profile_shortened and \".\" in profile_shortened\n            else [profile_shortened]\n        )\n        profile_key = ps_parts[0] if ps_parts else None\n        record = {\n            \"user\": self.user,\n            #\"gloda_db_path\": self.gloda_db_path,\n            #\"index_db_path\": self.index_db_path if self.index_db_path else \"-\",\n            \"profile\": profile_key,\n            \"gloda_updated\": self.gloda_db_update_time,\n            \"index_updated\": self.index_db_update_time\n            if self.index_db_update_time\n            else \"-\",\n        }\n        if index is not None:\n            record = {\"#\": index, **record}\n        return record\n</code></pre>"},{"location":"#thunderbird.mail.MailArchive.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization processing to set the database update times.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization processing to set the database update times.\n    \"\"\"\n    self.gloda_db_update_time = self._get_file_update_time(self.gloda_db_path)\n    self.index_db_path = os.path.join(\n        os.path.dirname(self.gloda_db_path), \"index_db.sqlite\"\n    )\n    if self.index_db_exists():\n        self.index_db_update_time = self._get_file_update_time(self.index_db_path)\n</code></pre>"},{"location":"#thunderbird.mail.MailArchive.index_db_exists","title":"<code>index_db_exists()</code>","text":"<p>Checks if the index database file exists and is not empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the index database file exists and has a size greater than zero, otherwise False.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def index_db_exists(self) -&gt; bool:\n    \"\"\"Checks if the index database file exists and is not empty.\n\n    Returns:\n        bool: True if the index database file exists and has a size greater than zero, otherwise False.\n    \"\"\"\n    # Check if the index database file exists and its size is greater than zero bytes\n    result: bool = (\n        os.path.isfile(self.index_db_path)\n        and os.path.getsize(self.index_db_path) &gt; 0\n    )\n    return result\n</code></pre>"},{"location":"#thunderbird.mail.MailArchive.to_dict","title":"<code>to_dict(index=None)</code>","text":"<p>Converts the mail archive data to a dictionary, including the update times for both databases.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>An optional index to be added to the dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: The dictionary representation of the mail archive.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def to_dict(self, index: int = None) -&gt; Dict[str, str]:\n    \"\"\"\n    Converts the mail archive data to a dictionary, including the update times for both databases.\n\n    Args:\n        index (int, optional): An optional index to be added to the dictionary.\n\n    Returns:\n        Dict[str, str]: The dictionary representation of the mail archive.\n    \"\"\"\n    profile_shortened = os.path.basename(self.profile) if self.profile else None\n    ps_parts = (\n        profile_shortened.split(\".\")\n        if profile_shortened and \".\" in profile_shortened\n        else [profile_shortened]\n    )\n    profile_key = ps_parts[0] if ps_parts else None\n    record = {\n        \"user\": self.user,\n        #\"gloda_db_path\": self.gloda_db_path,\n        #\"index_db_path\": self.index_db_path if self.index_db_path else \"-\",\n        \"profile\": profile_key,\n        \"gloda_updated\": self.gloda_db_update_time,\n        \"index_updated\": self.index_db_update_time\n        if self.index_db_update_time\n        else \"-\",\n    }\n    if index is not None:\n        record = {\"#\": index, **record}\n    return record\n</code></pre>"},{"location":"#thunderbird.mail.MailArchives","title":"<code>MailArchives</code>","text":"<p>Manages a collection of MailArchive instances for different users.</p> <p>Attributes:</p> Name Type Description <code>user_list</code> <code>List[str]</code> <p>A list of user names.</p> <code>mail_archives</code> <code>Dict[str, MailArchive]</code> <p>A dictionary mapping users to their MailArchive instances.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>class MailArchives:\n    \"\"\"\n    Manages a collection of MailArchive instances for different users.\n\n    Attributes:\n        user_list (List[str]): A list of user names.\n        mail_archives (Dict[str, MailArchive]): A dictionary mapping users to their MailArchive instances.\n    \"\"\"\n\n    def __init__(self, user_list: List[str]):\n        \"\"\"\n        Initializes the MailArchives with a list of users.\n\n        Args:\n            user_list (List[str]): A list of user names.\n        \"\"\"\n        self.user_list = user_list\n        self.mail_archives = self._create_mail_archives()\n\n    def _create_mail_archives(self) -&gt; Dict[str, MailArchive]:\n        \"\"\"\n        Creates MailArchive instances for each user in the user list.\n        \"\"\"\n        archives = {}\n        for user in self.user_list:\n            # Assuming Thunderbird.get(user) returns a Thunderbird instance with a valid mailbox DB path attribute\n            tb_instance = Thunderbird.get(user)\n            archives[user] = tb_instance\n        return archives\n\n    def as_view_lod(self) -&gt; List[Dict[str, str]]:\n        \"\"\"\n        Creates a list of dictionaries representation of the mail archives.\n\n        Returns:\n            List[Dict[str,str]]: A list of dictionaries, each representing a mail archive.\n        \"\"\"\n        lod = []\n        for index, archive in enumerate(self.mail_archives.values()):\n            record = archive.to_dict(index + 1)\n            user = record[\"user\"]\n            profile = record[\"profile\"]\n            profile_url = f\"/profile/{user}/{profile}\"\n            record[\"profile\"] = Link.create(profile_url, profile)\n            record[\"mailboxes\"] = Link.create(f\"{profile_url}/mailboxes\", \"mailboxes\")\n            record[\"search\"] = Link.create(f\"{profile_url}/search\", \"search\")\n            record[\"index\"] = Link.create(f\"{profile_url}/index\", \"index\")\n            # add restful call to update index\n            lod.append(record)\n        return lod\n</code></pre>"},{"location":"#thunderbird.mail.MailArchives.__init__","title":"<code>__init__(user_list)</code>","text":"<p>Initializes the MailArchives with a list of users.</p> <p>Parameters:</p> Name Type Description Default <code>user_list</code> <code>List[str]</code> <p>A list of user names.</p> required Source code in <code>thunderbird/mail.py</code> <pre><code>def __init__(self, user_list: List[str]):\n    \"\"\"\n    Initializes the MailArchives with a list of users.\n\n    Args:\n        user_list (List[str]): A list of user names.\n    \"\"\"\n    self.user_list = user_list\n    self.mail_archives = self._create_mail_archives()\n</code></pre>"},{"location":"#thunderbird.mail.MailArchives.as_view_lod","title":"<code>as_view_lod()</code>","text":"<p>Creates a list of dictionaries representation of the mail archives.</p> <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>List[Dict[str,str]]: A list of dictionaries, each representing a mail archive.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def as_view_lod(self) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    Creates a list of dictionaries representation of the mail archives.\n\n    Returns:\n        List[Dict[str,str]]: A list of dictionaries, each representing a mail archive.\n    \"\"\"\n    lod = []\n    for index, archive in enumerate(self.mail_archives.values()):\n        record = archive.to_dict(index + 1)\n        user = record[\"user\"]\n        profile = record[\"profile\"]\n        profile_url = f\"/profile/{user}/{profile}\"\n        record[\"profile\"] = Link.create(profile_url, profile)\n        record[\"mailboxes\"] = Link.create(f\"{profile_url}/mailboxes\", \"mailboxes\")\n        record[\"search\"] = Link.create(f\"{profile_url}/search\", \"search\")\n        record[\"index\"] = Link.create(f\"{profile_url}/index\", \"index\")\n        # add restful call to update index\n        lod.append(record)\n    return lod\n</code></pre>"},{"location":"#thunderbird.mail.MailLookup","title":"<code>MailLookup</code>  <code>dataclass</code>","text":"<p>A data class representing a mail lookup entity.</p> <p>Attributes:</p> Name Type Description <code>message_index</code> <code>int</code> <p>The index of the message.</p> <code>folder_path</code> <code>str</code> <p>The path to the folder containing the message.</p> <code>message_id</code> <code>str</code> <p>The unique identifier of the message.</p> <code>start_pos</code> <code>int</code> <p>The start byte position of the message in the mailbox file.</p> <code>stop_pos</code> <code>int</code> <p>The stop byte position of the message in the mailbox file.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@dataclass\nclass MailLookup:\n    \"\"\"\n    A data class representing a mail lookup entity.\n\n    Attributes:\n        message_index (int): The index of the message.\n        folder_path (str): The path to the folder containing the message.\n        message_id (str): The unique identifier of the message.\n        start_pos (int, optional): The start byte position of the message in the mailbox file.\n        stop_pos (int, optional): The stop byte position of the message in the mailbox file.\n    \"\"\"\n\n    message_index: int\n    folder_path: str\n    message_id: str\n    start_pos: Optional[int] = None\n    stop_pos: Optional[int] = None\n\n    @classmethod\n    def from_gloda_record(cls, mail_record: Dict) -&gt; \"MailLookup\":\n        \"\"\"\n        Creates a MailLookup instance from a Gloda record.\n\n        Args:\n            mail_record (Dict): A dictionary representing a Gloda record.\n\n        Returns:\n            MailLookup: An instance of MailLookup.\n        \"\"\"\n        message_id = mail_record[\"message_id\"]\n        folder_uri = mail_record[\"folderURI\"]\n        message_index = int(mail_record[\"messageKey\"])\n        folder_uri = urllib.parse.unquote(folder_uri)\n        sbd_folder, _folder = Mail.toSbdFolder(folder_uri)\n        relative_folder = ThunderbirdMailbox.as_relative_path(sbd_folder)\n        return cls(message_index, relative_folder, message_id)\n\n    @classmethod\n    def from_index_db_record(cls, mail_record: Dict) -&gt; \"MailLookup\":\n        \"\"\"\n        Creates a MailLookup instance from an index database record.\n\n        Args:\n            mail_record (Dict): A dictionary representing an index database record.\n\n        Returns:\n            MailLookup: An instance of MailLookup.\n        \"\"\"\n        message_id = mail_record[\"message_id\"]\n        message_index = mail_record[\"email_index\"]\n        folder_path = mail_record[\"folder_path\"]\n        start_pos = mail_record.get(\"start_pos\")  # Use .get to handle missing keys\n        stop_pos = mail_record.get(\"stop_pos\")\n        return cls(message_index, folder_path, message_id, start_pos, stop_pos)\n\n    @classmethod\n    def from_mail_record(cls, mail_record: Dict) -&gt; \"MailLookup\":\n        \"\"\"\n        Creates a MailLookup instance based on the source of the mail record.\n\n        Args:\n            mail_record (Dict): A dictionary containing the mail record.\n\n        Returns:\n            MailLookup: An instance of MailLookup based on the source.\n        \"\"\"\n        source = mail_record[\"source\"]\n        if source == \"gloda\":\n            return cls.from_gloda_record(mail_record)\n        else:\n            return cls.from_index_db_record(mail_record)\n</code></pre>"},{"location":"#thunderbird.mail.MailLookup.from_gloda_record","title":"<code>from_gloda_record(mail_record)</code>  <code>classmethod</code>","text":"<p>Creates a MailLookup instance from a Gloda record.</p> <p>Parameters:</p> Name Type Description Default <code>mail_record</code> <code>Dict</code> <p>A dictionary representing a Gloda record.</p> required <p>Returns:</p> Name Type Description <code>MailLookup</code> <code>MailLookup</code> <p>An instance of MailLookup.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef from_gloda_record(cls, mail_record: Dict) -&gt; \"MailLookup\":\n    \"\"\"\n    Creates a MailLookup instance from a Gloda record.\n\n    Args:\n        mail_record (Dict): A dictionary representing a Gloda record.\n\n    Returns:\n        MailLookup: An instance of MailLookup.\n    \"\"\"\n    message_id = mail_record[\"message_id\"]\n    folder_uri = mail_record[\"folderURI\"]\n    message_index = int(mail_record[\"messageKey\"])\n    folder_uri = urllib.parse.unquote(folder_uri)\n    sbd_folder, _folder = Mail.toSbdFolder(folder_uri)\n    relative_folder = ThunderbirdMailbox.as_relative_path(sbd_folder)\n    return cls(message_index, relative_folder, message_id)\n</code></pre>"},{"location":"#thunderbird.mail.MailLookup.from_index_db_record","title":"<code>from_index_db_record(mail_record)</code>  <code>classmethod</code>","text":"<p>Creates a MailLookup instance from an index database record.</p> <p>Parameters:</p> Name Type Description Default <code>mail_record</code> <code>Dict</code> <p>A dictionary representing an index database record.</p> required <p>Returns:</p> Name Type Description <code>MailLookup</code> <code>MailLookup</code> <p>An instance of MailLookup.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef from_index_db_record(cls, mail_record: Dict) -&gt; \"MailLookup\":\n    \"\"\"\n    Creates a MailLookup instance from an index database record.\n\n    Args:\n        mail_record (Dict): A dictionary representing an index database record.\n\n    Returns:\n        MailLookup: An instance of MailLookup.\n    \"\"\"\n    message_id = mail_record[\"message_id\"]\n    message_index = mail_record[\"email_index\"]\n    folder_path = mail_record[\"folder_path\"]\n    start_pos = mail_record.get(\"start_pos\")  # Use .get to handle missing keys\n    stop_pos = mail_record.get(\"stop_pos\")\n    return cls(message_index, folder_path, message_id, start_pos, stop_pos)\n</code></pre>"},{"location":"#thunderbird.mail.MailLookup.from_mail_record","title":"<code>from_mail_record(mail_record)</code>  <code>classmethod</code>","text":"<p>Creates a MailLookup instance based on the source of the mail record.</p> <p>Parameters:</p> Name Type Description Default <code>mail_record</code> <code>Dict</code> <p>A dictionary containing the mail record.</p> required <p>Returns:</p> Name Type Description <code>MailLookup</code> <code>MailLookup</code> <p>An instance of MailLookup based on the source.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef from_mail_record(cls, mail_record: Dict) -&gt; \"MailLookup\":\n    \"\"\"\n    Creates a MailLookup instance based on the source of the mail record.\n\n    Args:\n        mail_record (Dict): A dictionary containing the mail record.\n\n    Returns:\n        MailLookup: An instance of MailLookup based on the source.\n    \"\"\"\n    source = mail_record[\"source\"]\n    if source == \"gloda\":\n        return cls.from_gloda_record(mail_record)\n    else:\n        return cls.from_index_db_record(mail_record)\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird","title":"<code>Thunderbird</code>","text":"<p>               Bases: <code>MailArchive</code></p> <p>Thunderbird Mailbox access</p> Source code in <code>thunderbird/mail.py</code> <pre><code>class Thunderbird(MailArchive):\n    \"\"\"\n    Thunderbird Mailbox access\n    \"\"\"\n\n    profiles = {}\n\n    def __init__(self, user: str, db=None, profile=None):\n        \"\"\"\n        construct a Thunderbird access instance for the given user\n        \"\"\"\n        self.user = user\n        if db is None and profile is None:\n            profileMap = Thunderbird.getProfileMap()\n            if user in profileMap:\n                profile = profileMap[user]\n            else:\n                raise Exception(f\"user {user} missing in .thunderbird.yaml\")\n            db = profile[\"db\"]\n            profile = profile[\"profile\"]\n\n        # Call the super constructor\n        super().__init__(user=user, gloda_db_path=db, profile=profile)\n\n        try:\n            self.sqlDB = SQLDB(self.gloda_db_path, check_same_thread=False, timeout=5)\n        except sqlite3.OperationalError as soe:\n            print(f\"could not open database {self.db}: {soe}\")\n            raise soe\n        pass\n        self.index_db = SQLDB(self.index_db_path, check_same_thread=False)\n        self.local_folders = f\"{self.profile}/Mail/Local Folders\"\n        self.errors=[]\n\n    def get_mailboxes(self, progress_bar=None, restore_toc: bool = False):\n        \"\"\"\n        Create a dict of Thunderbird mailboxes.\n\n        \"\"\"\n        extensions = {\"Folder\": \".sbd\", \"Mailbox\": \"\"}\n        file_selector = FileSelector(\n            path=self.local_folders, extensions=extensions, create_ui=False\n        )\n        if progress_bar is not None:\n            progress_bar.total = file_selector.file_count\n        mailboxes = {}  # Dictionary to store ThunderbirdMailbox instances\n        self.errors=[]\n        self._traverse_tree(file_selector.tree_structure, mailboxes, progress_bar, restore_toc)\n        return mailboxes\n\n    def add_mailbox(self,mailbox_path,mailboxes, progress_bar, restore_toc:bool=False):\n        \"\"\"\n        add a ThunderbirdMailBox for the given mailbox_path to the mailboxes\n        \"\"\"\n        mailboxes[mailbox_path] = ThunderbirdMailbox(\n            self, mailbox_path, restore_toc=restore_toc\n        )\n        if progress_bar:\n            progress_bar.update(1)\n\n    def _traverse_tree(self, parent, mailboxes, progress_bar, restore_toc):\n        \"\"\"\n        traves the file system tree from the given parent node\n        \"\"\"\n        self._add_mailbox_from_node(parent, mailboxes, progress_bar, restore_toc)\n        for child in parent.get(\"children\", []):\n            self._traverse_tree(child, mailboxes, progress_bar, restore_toc)\n\n    def _add_mailbox_from_node(self, node, mailboxes, progress_bar, restore_toc):\n        \"\"\"\n        add a mailbox from the given file system tree node\n        \"\"\"\n        is_valid_mailbox=node[\"id\"] != \"1\" and not node[\"label\"].endswith(\".sbd\")\n        if is_valid_mailbox:\n            try:\n                mailbox_path = node[\"value\"]\n                self.add_mailbox(mailbox_path, mailboxes, progress_bar, restore_toc)\n            except ValueError as e:\n                errmsg=f\"{node['value']}: {str(e)}\"\n                self.errors.append(errmsg)\n\n    def get_mailboxes_by_relative_path(self) -&gt; Dict[str, \"ThunderbirdMailbox\"]:\n        \"\"\"\n        Retrieves all mailboxes and returns a dictionary keyed by their relative folder paths.\n\n        This method fetches all Thunderbird mailboxes and organizes them in a dictionary where the keys are the\n        relative paths of the mailboxes, providing a quick way to access a mailbox by its relative path.\n\n        Returns:\n            Dict[str, ThunderbirdMailbox]: A dictionary where the keys are relative folder paths and the values are\n                                           ThunderbirdMailbox objects representing the corresponding mailboxes.\n        \"\"\"\n        mailboxes_dict = self.get_mailboxes()\n        mailboxes_by_relative_path = {}\n        for mailbox in mailboxes_dict.values():\n            mailboxes_by_relative_path[mailbox.relative_folder_path] = mailbox\n        return mailboxes_by_relative_path\n\n    def to_view_lod(\n        self,\n        fs_mailboxes_dict: Dict[str, \"ThunderbirdMailbox\"],\n        db_mailboxes_dict: Dict[str, Any],\n        force_count: bool = False,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Merges mailbox information from the filesystem and SQL database into a unified view.\n\n        Args:\n            fs_mailboxes_dict (Dict[str, ThunderbirdMailbox]): Mailboxes from the filesystem.\n            db_mailboxes_dict (Dict[str, Any]): Mailboxes from the SQL database.\n            force_count(bool): if True get count from mailboxes (costly!)\n        Returns:\n            List[Dict[str, Any]]: A unified list of dictionaries, each representing a mailbox.\n        \"\"\"\n        merged_view_lod = []\n        all_keys = set(fs_mailboxes_dict.keys()) | set(db_mailboxes_dict.keys())\n        unknown = \"\u2753\"\n        disk_symbol = \"\ud83d\udcbe\"  # Symbol representing the filesystem\n        database_symbol = \"\ud83d\uddc4\ufe0f\"  # Symbol representing the database\n\n        for key in all_keys:\n            fs_mailbox = fs_mailboxes_dict.get(key)\n            db_mailbox = db_mailboxes_dict.get(key)\n\n            state_char = (\n                \"\ud83d\udd04\"\n                if fs_mailbox and db_mailbox\n                else disk_symbol\n                if fs_mailbox\n                else database_symbol\n            )\n            if db_mailbox and \"message_count\" in db_mailbox:\n                count_str = str(db_mailbox[\"message_count\"])\n            elif fs_mailbox and force_count:\n                count_str = (\n                    str(len(fs_mailbox.mbox)) if hasattr(fs_mailbox, \"mbox\") else \"\u26a0\ufe0f\u2753\"\n                )\n            else:\n                count_str = unknown\n            relative_folder_path = (\n                fs_mailbox.relative_folder_path\n                if fs_mailbox\n                else db_mailbox[\"relative_folder_path\"]\n            )\n            folder_url = (\n                f\"/folder/{self.user}{relative_folder_path}\" if fs_mailbox else \"#\"\n            )\n            error_str = (\n                fs_mailbox.error if fs_mailbox else db_mailbox.get(\"Error\", unknown)\n            )\n            fs_update_time = fs_mailbox.folder_update_time if fs_mailbox else unknown\n            db_update_time = db_mailbox[\"folder_update_time\"] if db_mailbox else unknown\n\n            mailbox_record = {\n                \"State\": state_char,\n                \"Folder\": Link.create(folder_url, relative_folder_path),\n                f\"{disk_symbol}-Updated\": fs_update_time,\n                f\"{database_symbol}-Updated\": db_update_time,\n                \"Count\": count_str,\n                \"Error\": error_str,\n            }\n            merged_view_lod.append(mailbox_record)\n\n        # Sorting by 'Updated' field\n        merged_view_lod.sort(key=lambda x: x[f\"{disk_symbol}-Updated\"], reverse=True)\n\n        # Assigning index after sorting\n        for index, record in enumerate(merged_view_lod):\n            merged_view_lod[index] = {\"#\": index, **record}\n\n        return merged_view_lod\n\n    def get_synched_mailbox_view_lod(self):\n        \"\"\"\n        Fetches and synchronizes mailbox data from the filesystem and SQL database and returns a unified view.\n\n        Returns:\n            List[Dict[str, Any]]: A unified list of dictionaries, each representing a mailbox.\n        \"\"\"\n        # Retrieve mailbox data from the filesystem\n        fs_mboxes_dict = self.get_mailboxes_by_relative_path()\n\n        # Retrieve mailbox data from the SQL database\n        db_mboxes_dict = self.get_mailboxes_dod_from_sqldb(\n            self.index_db\n        )  # Database mailboxes\n\n        # Merge and format the data for view\n        mboxes_view_lod = self.to_view_lod(fs_mboxes_dict, db_mboxes_dict)\n\n        return mboxes_view_lod\n\n    def get_mailboxes_dod_from_sqldb(self, sql_db: SQLDB) -&gt; dict:\n        \"\"\"\n        Retrieve the mailbox list of dictionaries (LoD) from the given SQL database,\n        and return it as a dictionary keyed by relative_folder_path.\n\n        Args:\n            sql_db (SQLDB): An instance of SQLDB connected to the SQLite database.\n\n        Returns:\n            dict: A dictionary of mailbox dictionaries, keyed by relative_folder_path.\n        \"\"\"\n        sql_query = \"\"\"SELECT *\n                       FROM mailboxes \n                       ORDER BY folder_update_time DESC\"\"\"\n        try:\n            mailboxes_lod = sql_db.query(sql_query)\n            mailboxes_dict = {mb[\"relative_folder_path\"]: mb for mb in mailboxes_lod}\n            return mailboxes_dict\n        except sqlite3.OperationalError as e:\n            if \"no such table\" in str(e):\n                return {}\n            else:\n                raise e\n\n    def index_mailbox(\n        self,\n        mailbox: \"ThunderbirdMailbox\",\n        progress_bar: Progressbar,\n        force_create: bool,\n    ) -&gt; tuple:\n        \"\"\"\n        Process a single mailbox for updating the index.\n\n        Args:\n            mailbox (ThunderbirdMailbox): The mailbox to be processed.\n            progress_bar (Progressbar): Progress bar object for visual feedback.\n            force_create (bool): Flag to force creation of a new index.\n\n        Returns:\n            tuple: A tuple containing the message count and any exception occurred.\n        \"\"\"\n        message_count = 0\n        exception = None\n\n        try:\n            mbox_lod = mailbox.get_index_lod()\n            message_count = len(mbox_lod)\n\n            if message_count &gt; 0:\n                with_create = not self.index_db_exists() or force_create\n                mbox_entity_info = self.index_db.createTable(\n                    mbox_lod,\n                    \"mail_index\",\n                    withCreate=with_create,\n                    withDrop=with_create,\n                )\n                # first delete existing index entries (if any)\n                delete_cmd = f\"DELETE FROM mail_index WHERE folder_path='{mailbox.relative_folder_path}'\"\n                self.index_db.execute(delete_cmd)\n                # then store the new ones\n                self.index_db.store(mbox_lod, mbox_entity_info, fixNone=True)\n\n        except Exception as ex:\n            exception = ex\n\n        progress_bar.update(1)  # Update the progress bar after processing each mailbox\n        return message_count, exception  # Single return statement\n\n    def prepare_mailboxes_for_indexing(\n        self,\n        ixs:IndexingState,\n        progress_bar: Optional[Progressbar] = None,\n        relative_paths: Optional[List[str]] = None,\n    ) -&gt; Tuple[Dict[str, \"ThunderbirdMailbox\"], Dict[str, \"ThunderbirdMailbox\"]]:\n        \"\"\"\n        Prepare a list of mailboxes for indexing by identifying which ones need to be updated.\n\n        This function iterates through all Thunderbird mailboxes, checking if each needs an update\n        based on the last update time in the index database. It returns two dictionaries: one containing\n        all mailboxes and another containing only the mailboxes that need updating.\n\n        Args:\n            ixs:IndexingState: the indexing state to work on\n            force_create (bool): Flag to force creation of a new index for all mailboxes.\n            progress_bar (Optional[Progressbar]): A progress bar instance for displaying the progress.\n            relative_paths (Optional[List[str]]): A list of relative paths for specific mailboxes to update. If None, all mailboxes are considered.\n\n        Returns:\n            Tuple[Dict[str, ThunderbirdMailbox], Dict[str, ThunderbirdMailbox]]: A tuple containing two dictionaries.\n                The first dictionary contains all mailboxes, and the second contains only mailboxes that need updating.\n        \"\"\"\n\n        # optionally Retrieve all mailboxes\n        if not relative_paths:\n            ixs.all_mailboxes = self.get_mailboxes(progress_bar)\n        else:\n            ixs.all_mailboxes = {}\n            for relative_path in relative_paths:\n                mailbox_path = f\"{self.profile}/Mail/Local Folders{relative_path}\"\n                mailbox = ThunderbirdMailbox(self, mailbox_path)\n                ixs.all_mailboxes[mailbox_path] = mailbox\n        # Retrieve the current state of mailboxes from the index database, if not forcing creation\n        mailboxes_update_dod = {}\n        if not ixs.force_create:\n            mailboxes_update_dod = self.get_mailboxes_dod_from_sqldb(self.index_db)\n\n        # List to hold mailboxes that need updating\n        ixs.mailboxes_to_update = {}\n\n        # Iterate through each mailbox to check if it needs updating\n        if ixs.force_create:\n            # If force_create is True, add all mailboxes to the update list\n            for mailbox in ixs.all_mailboxes.values():\n                ixs.mailboxes_to_update[mailbox.relative_folder_path] = mailbox\n        else:\n            if relative_paths is not None:\n                for mailbox in ixs.all_mailboxes.values():\n                    if mailbox.relative_folder_path in relative_paths:\n                        ixs.mailboxes_to_update[mailbox.relative_folder_path] = mailbox\n            else:\n                for mailbox in ixs.all_mailboxes.values():\n                    # Check update times only if not forcing creation\n                    mailbox_info = mailboxes_update_dod.get(\n                        mailbox.relative_folder_path, {}\n                    )\n                    _prev_mailbox_update_time = mailbox_info.get(\"folder_update_time\")\n                    current_folder_update_time = mailbox.folder_update_time\n\n                    # Check if the mailbox needs updating\n                    if (\n                        self.index_db_update_time is None\n                    ) or current_folder_update_time &gt; self.index_db_update_time:\n                        ixs.mailboxes_to_update[mailbox.relative_folder_path] = mailbox\n        ixs.total_mailboxes = len(ixs.mailboxes_to_update)\n        if progress_bar:\n            progress_bar.total = ixs.total_mailboxes\n            progress_bar.reset()\n\n\n    def get_indexing_state(self, force_create: bool=False) -&gt; IndexingState:\n        \"\"\"\n        Check if the index database needs to be updated or created.\n\n        Args:\n            force_create (bool): Flag to force creation of a new index.\n\n        Returns:\n            IndexingState\n        \"\"\"\n        gloda_db_update_time = (\n            datetime.fromtimestamp(os.path.getmtime(self.gloda_db_path))\n            if self.gloda_db_path\n            else None\n        )\n        index_db_update_time = (\n            datetime.fromtimestamp(os.path.getmtime(self.index_db_path))\n            if self.index_db_exists()\n            else None\n        )\n        index_up_to_date = (\n            self.index_db_exists() and index_db_update_time &gt; gloda_db_update_time\n        )\n        ixs=IndexingState(\n            gloda_db_update_time=gloda_db_update_time,\n            index_db_update_time=index_db_update_time,\n            force_create=force_create)\n        ixs.needs_update = not index_up_to_date or force_create\n        marker = \"\u274c \" if ixs.needs_update else \"\u2705\"\n        ixs.state_msg = f\"\"\"{marker} {self.user} update times:\nIndex db: {ixs.index_db_update_time} \n   Gloda: {ixs.gloda_db_update_time}\n\"\"\"\n        return ixs\n\n    def create_or_update_index(self,\n        relative_paths: Optional[List[str]] = None,\n        force_create:bool=False)-&gt;IndexingState:\n        # Initialize IndexingResult\n        ixs=self.get_indexing_state(force_create)\n        self.do_create_or_update_index(ixs,relative_paths=relative_paths)\n        return ixs\n\n    def do_create_or_update_index(\n        self,\n        ixs:IndexingState,\n        progress_bar: Optional[Progressbar] = None,\n        relative_paths: Optional[List[str]] = None,\n        callback:callable = None\n    ) :\n        \"\"\"\n        Create or update an index of emails from Thunderbird mailboxes, storing the data in an SQLite database.\n        If an index already exists and is up-to-date, this method will update it instead of creating a new one.\n\n        Args:\n            ixs:IndexingState: the indexing state to work with\n            progress_bar (Progressbar, optional): Progress bar to display the progress of index creation.\n            relative_paths (Optional[List[str]]): List of relative mailbox paths to specifically update. If None, updates all mailboxes or based on `force_create`.\n\n        \"\"\"\n        if ixs.needs_update or relative_paths:\n            if progress_bar is None:\n                progress_bar = TqdmProgressbar(\n                    total=ixs.total_mailboxes, desc=\"create index\", unit=\"mailbox\"\n                )\n\n            self.prepare_mailboxes_for_indexing(ixs=ixs,\n               progress_bar=progress_bar, \n               relative_paths=relative_paths\n            )\n\n            needs_create = ixs.force_create or not self.index_db_exists()\n            for mailbox in ixs.mailboxes_to_update.values():\n                message_count, exception = self.index_mailbox(\n                    mailbox, progress_bar, needs_create\n                )\n                if message_count &gt; 0 and needs_create:\n                    needs_create = (\n                        False  # Subsequent updates will not recreate the table\n                    )\n\n                if exception:\n                    mailbox.error = exception\n                    ixs.errors[mailbox.folder_path] = exception\n                else:\n                    ixs.success[mailbox.folder_path] = message_count\n                ixs.update_msg()\n                if callback:\n                    callback(mailbox,message_count)\n            # if not relative paths were set we need to recreate the mailboxes table\n            needs_create = relative_paths is None\n            if relative_paths:\n                # Delete existing entries for updated mailboxes\n                for relative_path in relative_paths:\n                    delete_query = (\n                        f\"DELETE FROM mailboxes WHERE folder_path = '{relative_path}'\"\n                    )\n                    self.index_db.execute(delete_query)\n\n                # Re-create the list of dictionaries for all selected mailboxes\n                mailboxes_lod = [\n                    mailbox.to_dict() for mailbox in ixs.mailboxes_to_update.values()\n                ]\n            else:\n                mailboxes_lod = [\n                    mailbox.to_dict() for mailbox in ixs.all_mailboxes.values()\n                ]\n            mailboxes_entity_info = self.index_db.createTable(\n                mailboxes_lod,\n                \"mailboxes\",\n                withCreate=needs_create,\n                withDrop=needs_create,\n            )\n            # Store the mailbox data in the 'mailboxes' table\n            if len(mailboxes_lod) &gt; 0:\n                self.index_db.store(mailboxes_lod, mailboxes_entity_info)\n        else:\n            ixs.msg=ixs.state_msg\n\n    @classmethod\n    def get_config_path(cls) -&gt; str:\n        home = str(Path.home())\n        return os.path.join(home, \".thunderbird\")\n\n    @classmethod\n    def get_profiles_path(cls) -&gt; str:\n        \"\"\"\n        get the profile path\n        \"\"\"\n        config_path = cls.get_config_path()\n        # Ensure the config_path exists\n        os.makedirs(config_path, exist_ok=True)\n\n        profiles_path = os.path.join(config_path, \"thunderbird.yaml\")\n        return profiles_path\n\n    @classmethod\n    def getProfileMap(cls):\n        \"\"\"\n        get the profile map from a thunderbird.yaml file\n        \"\"\"\n        profiles_path = cls.get_profiles_path()\n        with open(profiles_path, \"r\") as stream:\n            profile_map = yaml.safe_load(stream)\n        return profile_map\n\n    @staticmethod\n    def get(user):\n        if not user in Thunderbird.profiles:\n            tb = Thunderbird(user)\n            Thunderbird.profiles[user] = tb\n        return Thunderbird.profiles[user]\n\n    def query(self, sql_query: str, params):\n        \"\"\"\n        query this mailbox gloda\n\n        Args:\n            sql_query(str): the sql query to execute\n            params: the parameters for the query\n        \"\"\"\n        records = self.sqlDB.query(sql_query, params)\n        return records\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.__init__","title":"<code>__init__(user, db=None, profile=None)</code>","text":"<p>construct a Thunderbird access instance for the given user</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def __init__(self, user: str, db=None, profile=None):\n    \"\"\"\n    construct a Thunderbird access instance for the given user\n    \"\"\"\n    self.user = user\n    if db is None and profile is None:\n        profileMap = Thunderbird.getProfileMap()\n        if user in profileMap:\n            profile = profileMap[user]\n        else:\n            raise Exception(f\"user {user} missing in .thunderbird.yaml\")\n        db = profile[\"db\"]\n        profile = profile[\"profile\"]\n\n    # Call the super constructor\n    super().__init__(user=user, gloda_db_path=db, profile=profile)\n\n    try:\n        self.sqlDB = SQLDB(self.gloda_db_path, check_same_thread=False, timeout=5)\n    except sqlite3.OperationalError as soe:\n        print(f\"could not open database {self.db}: {soe}\")\n        raise soe\n    pass\n    self.index_db = SQLDB(self.index_db_path, check_same_thread=False)\n    self.local_folders = f\"{self.profile}/Mail/Local Folders\"\n    self.errors=[]\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.add_mailbox","title":"<code>add_mailbox(mailbox_path, mailboxes, progress_bar, restore_toc=False)</code>","text":"<p>add a ThunderbirdMailBox for the given mailbox_path to the mailboxes</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def add_mailbox(self,mailbox_path,mailboxes, progress_bar, restore_toc:bool=False):\n    \"\"\"\n    add a ThunderbirdMailBox for the given mailbox_path to the mailboxes\n    \"\"\"\n    mailboxes[mailbox_path] = ThunderbirdMailbox(\n        self, mailbox_path, restore_toc=restore_toc\n    )\n    if progress_bar:\n        progress_bar.update(1)\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.do_create_or_update_index","title":"<code>do_create_or_update_index(ixs, progress_bar=None, relative_paths=None, callback=None)</code>","text":"<p>Create or update an index of emails from Thunderbird mailboxes, storing the data in an SQLite database. If an index already exists and is up-to-date, this method will update it instead of creating a new one.</p> <p>Parameters:</p> Name Type Description Default <code>ixs</code> <code>IndexingState</code> <p>IndexingState: the indexing state to work with</p> required <code>progress_bar</code> <code>Progressbar</code> <p>Progress bar to display the progress of index creation.</p> <code>None</code> <code>relative_paths</code> <code>Optional[List[str]]</code> <p>List of relative mailbox paths to specifically update. If None, updates all mailboxes or based on <code>force_create</code>.</p> <code>None</code> Source code in <code>thunderbird/mail.py</code> <pre><code>def do_create_or_update_index(\n    self,\n    ixs:IndexingState,\n    progress_bar: Optional[Progressbar] = None,\n    relative_paths: Optional[List[str]] = None,\n    callback:callable = None\n) :\n    \"\"\"\n    Create or update an index of emails from Thunderbird mailboxes, storing the data in an SQLite database.\n    If an index already exists and is up-to-date, this method will update it instead of creating a new one.\n\n    Args:\n        ixs:IndexingState: the indexing state to work with\n        progress_bar (Progressbar, optional): Progress bar to display the progress of index creation.\n        relative_paths (Optional[List[str]]): List of relative mailbox paths to specifically update. If None, updates all mailboxes or based on `force_create`.\n\n    \"\"\"\n    if ixs.needs_update or relative_paths:\n        if progress_bar is None:\n            progress_bar = TqdmProgressbar(\n                total=ixs.total_mailboxes, desc=\"create index\", unit=\"mailbox\"\n            )\n\n        self.prepare_mailboxes_for_indexing(ixs=ixs,\n           progress_bar=progress_bar, \n           relative_paths=relative_paths\n        )\n\n        needs_create = ixs.force_create or not self.index_db_exists()\n        for mailbox in ixs.mailboxes_to_update.values():\n            message_count, exception = self.index_mailbox(\n                mailbox, progress_bar, needs_create\n            )\n            if message_count &gt; 0 and needs_create:\n                needs_create = (\n                    False  # Subsequent updates will not recreate the table\n                )\n\n            if exception:\n                mailbox.error = exception\n                ixs.errors[mailbox.folder_path] = exception\n            else:\n                ixs.success[mailbox.folder_path] = message_count\n            ixs.update_msg()\n            if callback:\n                callback(mailbox,message_count)\n        # if not relative paths were set we need to recreate the mailboxes table\n        needs_create = relative_paths is None\n        if relative_paths:\n            # Delete existing entries for updated mailboxes\n            for relative_path in relative_paths:\n                delete_query = (\n                    f\"DELETE FROM mailboxes WHERE folder_path = '{relative_path}'\"\n                )\n                self.index_db.execute(delete_query)\n\n            # Re-create the list of dictionaries for all selected mailboxes\n            mailboxes_lod = [\n                mailbox.to_dict() for mailbox in ixs.mailboxes_to_update.values()\n            ]\n        else:\n            mailboxes_lod = [\n                mailbox.to_dict() for mailbox in ixs.all_mailboxes.values()\n            ]\n        mailboxes_entity_info = self.index_db.createTable(\n            mailboxes_lod,\n            \"mailboxes\",\n            withCreate=needs_create,\n            withDrop=needs_create,\n        )\n        # Store the mailbox data in the 'mailboxes' table\n        if len(mailboxes_lod) &gt; 0:\n            self.index_db.store(mailboxes_lod, mailboxes_entity_info)\n    else:\n        ixs.msg=ixs.state_msg\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.getProfileMap","title":"<code>getProfileMap()</code>  <code>classmethod</code>","text":"<p>get the profile map from a thunderbird.yaml file</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef getProfileMap(cls):\n    \"\"\"\n    get the profile map from a thunderbird.yaml file\n    \"\"\"\n    profiles_path = cls.get_profiles_path()\n    with open(profiles_path, \"r\") as stream:\n        profile_map = yaml.safe_load(stream)\n    return profile_map\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.get_indexing_state","title":"<code>get_indexing_state(force_create=False)</code>","text":"<p>Check if the index database needs to be updated or created.</p> <p>Parameters:</p> Name Type Description Default <code>force_create</code> <code>bool</code> <p>Flag to force creation of a new index.</p> <code>False</code> <p>Returns:</p> Type Description <code>IndexingState</code> <p>IndexingState</p> Source code in <code>thunderbird/mail.py</code> <pre><code>    def get_indexing_state(self, force_create: bool=False) -&gt; IndexingState:\n        \"\"\"\n        Check if the index database needs to be updated or created.\n\n        Args:\n            force_create (bool): Flag to force creation of a new index.\n\n        Returns:\n            IndexingState\n        \"\"\"\n        gloda_db_update_time = (\n            datetime.fromtimestamp(os.path.getmtime(self.gloda_db_path))\n            if self.gloda_db_path\n            else None\n        )\n        index_db_update_time = (\n            datetime.fromtimestamp(os.path.getmtime(self.index_db_path))\n            if self.index_db_exists()\n            else None\n        )\n        index_up_to_date = (\n            self.index_db_exists() and index_db_update_time &gt; gloda_db_update_time\n        )\n        ixs=IndexingState(\n            gloda_db_update_time=gloda_db_update_time,\n            index_db_update_time=index_db_update_time,\n            force_create=force_create)\n        ixs.needs_update = not index_up_to_date or force_create\n        marker = \"\u274c \" if ixs.needs_update else \"\u2705\"\n        ixs.state_msg = f\"\"\"{marker} {self.user} update times:\nIndex db: {ixs.index_db_update_time} \n   Gloda: {ixs.gloda_db_update_time}\n\"\"\"\n        return ixs\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.get_mailboxes","title":"<code>get_mailboxes(progress_bar=None, restore_toc=False)</code>","text":"<p>Create a dict of Thunderbird mailboxes.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_mailboxes(self, progress_bar=None, restore_toc: bool = False):\n    \"\"\"\n    Create a dict of Thunderbird mailboxes.\n\n    \"\"\"\n    extensions = {\"Folder\": \".sbd\", \"Mailbox\": \"\"}\n    file_selector = FileSelector(\n        path=self.local_folders, extensions=extensions, create_ui=False\n    )\n    if progress_bar is not None:\n        progress_bar.total = file_selector.file_count\n    mailboxes = {}  # Dictionary to store ThunderbirdMailbox instances\n    self.errors=[]\n    self._traverse_tree(file_selector.tree_structure, mailboxes, progress_bar, restore_toc)\n    return mailboxes\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.get_mailboxes_by_relative_path","title":"<code>get_mailboxes_by_relative_path()</code>","text":"<p>Retrieves all mailboxes and returns a dictionary keyed by their relative folder paths.</p> <p>This method fetches all Thunderbird mailboxes and organizes them in a dictionary where the keys are the relative paths of the mailboxes, providing a quick way to access a mailbox by its relative path.</p> <p>Returns:</p> Type Description <code>Dict[str, ThunderbirdMailbox]</code> <p>Dict[str, ThunderbirdMailbox]: A dictionary where the keys are relative folder paths and the values are                            ThunderbirdMailbox objects representing the corresponding mailboxes.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_mailboxes_by_relative_path(self) -&gt; Dict[str, \"ThunderbirdMailbox\"]:\n    \"\"\"\n    Retrieves all mailboxes and returns a dictionary keyed by their relative folder paths.\n\n    This method fetches all Thunderbird mailboxes and organizes them in a dictionary where the keys are the\n    relative paths of the mailboxes, providing a quick way to access a mailbox by its relative path.\n\n    Returns:\n        Dict[str, ThunderbirdMailbox]: A dictionary where the keys are relative folder paths and the values are\n                                       ThunderbirdMailbox objects representing the corresponding mailboxes.\n    \"\"\"\n    mailboxes_dict = self.get_mailboxes()\n    mailboxes_by_relative_path = {}\n    for mailbox in mailboxes_dict.values():\n        mailboxes_by_relative_path[mailbox.relative_folder_path] = mailbox\n    return mailboxes_by_relative_path\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.get_mailboxes_dod_from_sqldb","title":"<code>get_mailboxes_dod_from_sqldb(sql_db)</code>","text":"<p>Retrieve the mailbox list of dictionaries (LoD) from the given SQL database, and return it as a dictionary keyed by relative_folder_path.</p> <p>Parameters:</p> Name Type Description Default <code>sql_db</code> <code>SQLDB</code> <p>An instance of SQLDB connected to the SQLite database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of mailbox dictionaries, keyed by relative_folder_path.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_mailboxes_dod_from_sqldb(self, sql_db: SQLDB) -&gt; dict:\n    \"\"\"\n    Retrieve the mailbox list of dictionaries (LoD) from the given SQL database,\n    and return it as a dictionary keyed by relative_folder_path.\n\n    Args:\n        sql_db (SQLDB): An instance of SQLDB connected to the SQLite database.\n\n    Returns:\n        dict: A dictionary of mailbox dictionaries, keyed by relative_folder_path.\n    \"\"\"\n    sql_query = \"\"\"SELECT *\n                   FROM mailboxes \n                   ORDER BY folder_update_time DESC\"\"\"\n    try:\n        mailboxes_lod = sql_db.query(sql_query)\n        mailboxes_dict = {mb[\"relative_folder_path\"]: mb for mb in mailboxes_lod}\n        return mailboxes_dict\n    except sqlite3.OperationalError as e:\n        if \"no such table\" in str(e):\n            return {}\n        else:\n            raise e\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.get_profiles_path","title":"<code>get_profiles_path()</code>  <code>classmethod</code>","text":"<p>get the profile path</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef get_profiles_path(cls) -&gt; str:\n    \"\"\"\n    get the profile path\n    \"\"\"\n    config_path = cls.get_config_path()\n    # Ensure the config_path exists\n    os.makedirs(config_path, exist_ok=True)\n\n    profiles_path = os.path.join(config_path, \"thunderbird.yaml\")\n    return profiles_path\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.get_synched_mailbox_view_lod","title":"<code>get_synched_mailbox_view_lod()</code>","text":"<p>Fetches and synchronizes mailbox data from the filesystem and SQL database and returns a unified view.</p> <p>Returns:</p> Type Description <p>List[Dict[str, Any]]: A unified list of dictionaries, each representing a mailbox.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_synched_mailbox_view_lod(self):\n    \"\"\"\n    Fetches and synchronizes mailbox data from the filesystem and SQL database and returns a unified view.\n\n    Returns:\n        List[Dict[str, Any]]: A unified list of dictionaries, each representing a mailbox.\n    \"\"\"\n    # Retrieve mailbox data from the filesystem\n    fs_mboxes_dict = self.get_mailboxes_by_relative_path()\n\n    # Retrieve mailbox data from the SQL database\n    db_mboxes_dict = self.get_mailboxes_dod_from_sqldb(\n        self.index_db\n    )  # Database mailboxes\n\n    # Merge and format the data for view\n    mboxes_view_lod = self.to_view_lod(fs_mboxes_dict, db_mboxes_dict)\n\n    return mboxes_view_lod\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.index_mailbox","title":"<code>index_mailbox(mailbox, progress_bar, force_create)</code>","text":"<p>Process a single mailbox for updating the index.</p> <p>Parameters:</p> Name Type Description Default <code>mailbox</code> <code>ThunderbirdMailbox</code> <p>The mailbox to be processed.</p> required <code>progress_bar</code> <code>Progressbar</code> <p>Progress bar object for visual feedback.</p> required <code>force_create</code> <code>bool</code> <p>Flag to force creation of a new index.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the message count and any exception occurred.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def index_mailbox(\n    self,\n    mailbox: \"ThunderbirdMailbox\",\n    progress_bar: Progressbar,\n    force_create: bool,\n) -&gt; tuple:\n    \"\"\"\n    Process a single mailbox for updating the index.\n\n    Args:\n        mailbox (ThunderbirdMailbox): The mailbox to be processed.\n        progress_bar (Progressbar): Progress bar object for visual feedback.\n        force_create (bool): Flag to force creation of a new index.\n\n    Returns:\n        tuple: A tuple containing the message count and any exception occurred.\n    \"\"\"\n    message_count = 0\n    exception = None\n\n    try:\n        mbox_lod = mailbox.get_index_lod()\n        message_count = len(mbox_lod)\n\n        if message_count &gt; 0:\n            with_create = not self.index_db_exists() or force_create\n            mbox_entity_info = self.index_db.createTable(\n                mbox_lod,\n                \"mail_index\",\n                withCreate=with_create,\n                withDrop=with_create,\n            )\n            # first delete existing index entries (if any)\n            delete_cmd = f\"DELETE FROM mail_index WHERE folder_path='{mailbox.relative_folder_path}'\"\n            self.index_db.execute(delete_cmd)\n            # then store the new ones\n            self.index_db.store(mbox_lod, mbox_entity_info, fixNone=True)\n\n    except Exception as ex:\n        exception = ex\n\n    progress_bar.update(1)  # Update the progress bar after processing each mailbox\n    return message_count, exception  # Single return statement\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.prepare_mailboxes_for_indexing","title":"<code>prepare_mailboxes_for_indexing(ixs, progress_bar=None, relative_paths=None)</code>","text":"<p>Prepare a list of mailboxes for indexing by identifying which ones need to be updated.</p> <p>This function iterates through all Thunderbird mailboxes, checking if each needs an update based on the last update time in the index database. It returns two dictionaries: one containing all mailboxes and another containing only the mailboxes that need updating.</p> <p>Parameters:</p> Name Type Description Default <code>ixs</code> <code>IndexingState</code> <p>IndexingState: the indexing state to work on</p> required <code>force_create</code> <code>bool</code> <p>Flag to force creation of a new index for all mailboxes.</p> required <code>progress_bar</code> <code>Optional[Progressbar]</code> <p>A progress bar instance for displaying the progress.</p> <code>None</code> <code>relative_paths</code> <code>Optional[List[str]]</code> <p>A list of relative paths for specific mailboxes to update. If None, all mailboxes are considered.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, ThunderbirdMailbox], Dict[str, ThunderbirdMailbox]]</code> <p>Tuple[Dict[str, ThunderbirdMailbox], Dict[str, ThunderbirdMailbox]]: A tuple containing two dictionaries. The first dictionary contains all mailboxes, and the second contains only mailboxes that need updating.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def prepare_mailboxes_for_indexing(\n    self,\n    ixs:IndexingState,\n    progress_bar: Optional[Progressbar] = None,\n    relative_paths: Optional[List[str]] = None,\n) -&gt; Tuple[Dict[str, \"ThunderbirdMailbox\"], Dict[str, \"ThunderbirdMailbox\"]]:\n    \"\"\"\n    Prepare a list of mailboxes for indexing by identifying which ones need to be updated.\n\n    This function iterates through all Thunderbird mailboxes, checking if each needs an update\n    based on the last update time in the index database. It returns two dictionaries: one containing\n    all mailboxes and another containing only the mailboxes that need updating.\n\n    Args:\n        ixs:IndexingState: the indexing state to work on\n        force_create (bool): Flag to force creation of a new index for all mailboxes.\n        progress_bar (Optional[Progressbar]): A progress bar instance for displaying the progress.\n        relative_paths (Optional[List[str]]): A list of relative paths for specific mailboxes to update. If None, all mailboxes are considered.\n\n    Returns:\n        Tuple[Dict[str, ThunderbirdMailbox], Dict[str, ThunderbirdMailbox]]: A tuple containing two dictionaries.\n            The first dictionary contains all mailboxes, and the second contains only mailboxes that need updating.\n    \"\"\"\n\n    # optionally Retrieve all mailboxes\n    if not relative_paths:\n        ixs.all_mailboxes = self.get_mailboxes(progress_bar)\n    else:\n        ixs.all_mailboxes = {}\n        for relative_path in relative_paths:\n            mailbox_path = f\"{self.profile}/Mail/Local Folders{relative_path}\"\n            mailbox = ThunderbirdMailbox(self, mailbox_path)\n            ixs.all_mailboxes[mailbox_path] = mailbox\n    # Retrieve the current state of mailboxes from the index database, if not forcing creation\n    mailboxes_update_dod = {}\n    if not ixs.force_create:\n        mailboxes_update_dod = self.get_mailboxes_dod_from_sqldb(self.index_db)\n\n    # List to hold mailboxes that need updating\n    ixs.mailboxes_to_update = {}\n\n    # Iterate through each mailbox to check if it needs updating\n    if ixs.force_create:\n        # If force_create is True, add all mailboxes to the update list\n        for mailbox in ixs.all_mailboxes.values():\n            ixs.mailboxes_to_update[mailbox.relative_folder_path] = mailbox\n    else:\n        if relative_paths is not None:\n            for mailbox in ixs.all_mailboxes.values():\n                if mailbox.relative_folder_path in relative_paths:\n                    ixs.mailboxes_to_update[mailbox.relative_folder_path] = mailbox\n        else:\n            for mailbox in ixs.all_mailboxes.values():\n                # Check update times only if not forcing creation\n                mailbox_info = mailboxes_update_dod.get(\n                    mailbox.relative_folder_path, {}\n                )\n                _prev_mailbox_update_time = mailbox_info.get(\"folder_update_time\")\n                current_folder_update_time = mailbox.folder_update_time\n\n                # Check if the mailbox needs updating\n                if (\n                    self.index_db_update_time is None\n                ) or current_folder_update_time &gt; self.index_db_update_time:\n                    ixs.mailboxes_to_update[mailbox.relative_folder_path] = mailbox\n    ixs.total_mailboxes = len(ixs.mailboxes_to_update)\n    if progress_bar:\n        progress_bar.total = ixs.total_mailboxes\n        progress_bar.reset()\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.query","title":"<code>query(sql_query, params)</code>","text":"<p>query this mailbox gloda</p> <p>Parameters:</p> Name Type Description Default <code>sql_query(str)</code> <p>the sql query to execute</p> required <code>params</code> <p>the parameters for the query</p> required Source code in <code>thunderbird/mail.py</code> <pre><code>def query(self, sql_query: str, params):\n    \"\"\"\n    query this mailbox gloda\n\n    Args:\n        sql_query(str): the sql query to execute\n        params: the parameters for the query\n    \"\"\"\n    records = self.sqlDB.query(sql_query, params)\n    return records\n</code></pre>"},{"location":"#thunderbird.mail.Thunderbird.to_view_lod","title":"<code>to_view_lod(fs_mailboxes_dict, db_mailboxes_dict, force_count=False)</code>","text":"<p>Merges mailbox information from the filesystem and SQL database into a unified view.</p> <p>Parameters:</p> Name Type Description Default <code>fs_mailboxes_dict</code> <code>Dict[str, ThunderbirdMailbox]</code> <p>Mailboxes from the filesystem.</p> required <code>db_mailboxes_dict</code> <code>Dict[str, Any]</code> <p>Mailboxes from the SQL database.</p> required <code>force_count(bool)</code> <p>if True get count from mailboxes (costly!)</p> required <p>Returns:     List[Dict[str, Any]]: A unified list of dictionaries, each representing a mailbox.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def to_view_lod(\n    self,\n    fs_mailboxes_dict: Dict[str, \"ThunderbirdMailbox\"],\n    db_mailboxes_dict: Dict[str, Any],\n    force_count: bool = False,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Merges mailbox information from the filesystem and SQL database into a unified view.\n\n    Args:\n        fs_mailboxes_dict (Dict[str, ThunderbirdMailbox]): Mailboxes from the filesystem.\n        db_mailboxes_dict (Dict[str, Any]): Mailboxes from the SQL database.\n        force_count(bool): if True get count from mailboxes (costly!)\n    Returns:\n        List[Dict[str, Any]]: A unified list of dictionaries, each representing a mailbox.\n    \"\"\"\n    merged_view_lod = []\n    all_keys = set(fs_mailboxes_dict.keys()) | set(db_mailboxes_dict.keys())\n    unknown = \"\u2753\"\n    disk_symbol = \"\ud83d\udcbe\"  # Symbol representing the filesystem\n    database_symbol = \"\ud83d\uddc4\ufe0f\"  # Symbol representing the database\n\n    for key in all_keys:\n        fs_mailbox = fs_mailboxes_dict.get(key)\n        db_mailbox = db_mailboxes_dict.get(key)\n\n        state_char = (\n            \"\ud83d\udd04\"\n            if fs_mailbox and db_mailbox\n            else disk_symbol\n            if fs_mailbox\n            else database_symbol\n        )\n        if db_mailbox and \"message_count\" in db_mailbox:\n            count_str = str(db_mailbox[\"message_count\"])\n        elif fs_mailbox and force_count:\n            count_str = (\n                str(len(fs_mailbox.mbox)) if hasattr(fs_mailbox, \"mbox\") else \"\u26a0\ufe0f\u2753\"\n            )\n        else:\n            count_str = unknown\n        relative_folder_path = (\n            fs_mailbox.relative_folder_path\n            if fs_mailbox\n            else db_mailbox[\"relative_folder_path\"]\n        )\n        folder_url = (\n            f\"/folder/{self.user}{relative_folder_path}\" if fs_mailbox else \"#\"\n        )\n        error_str = (\n            fs_mailbox.error if fs_mailbox else db_mailbox.get(\"Error\", unknown)\n        )\n        fs_update_time = fs_mailbox.folder_update_time if fs_mailbox else unknown\n        db_update_time = db_mailbox[\"folder_update_time\"] if db_mailbox else unknown\n\n        mailbox_record = {\n            \"State\": state_char,\n            \"Folder\": Link.create(folder_url, relative_folder_path),\n            f\"{disk_symbol}-Updated\": fs_update_time,\n            f\"{database_symbol}-Updated\": db_update_time,\n            \"Count\": count_str,\n            \"Error\": error_str,\n        }\n        merged_view_lod.append(mailbox_record)\n\n    # Sorting by 'Updated' field\n    merged_view_lod.sort(key=lambda x: x[f\"{disk_symbol}-Updated\"], reverse=True)\n\n    # Assigning index after sorting\n    for index, record in enumerate(merged_view_lod):\n        merged_view_lod[index] = {\"#\": index, **record}\n\n    return merged_view_lod\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox","title":"<code>ThunderbirdMailbox</code>","text":"<p>mailbox wrapper</p> Source code in <code>thunderbird/mail.py</code> <pre><code>class ThunderbirdMailbox:\n    \"\"\"\n    mailbox wrapper\n    \"\"\"\n\n    def __init__(\n        self,\n        tb: Thunderbird,\n        folder_path: str,\n        use_relative_path: bool = False,\n        restore_toc: bool = True,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Initializes a new Mailbox object associated with a specific Thunderbird email client and mailbox folder.\n\n        Args:\n            tb (Thunderbird): An instance of the Thunderbird class representing the email client to which this mailbox belongs.\n            folder_path (str): The file system path to the mailbox folder.\n            use_relative_path (bool): If True, use a relative path for the mailbox folder. Default is False.\n            restore_toc(bool): If True restore the table of contents\n            debug (bool, optional): A flag for enabling debug mode. Default is False.\n\n        The constructor sets the Thunderbird instance, folder path, and debug flag. It checks if the provided folder_path\n        is a valid file and raises a ValueError if it does not exist. The method also handles the extraction of\n        the relative folder path from the provided folder_path, especially handling the case where \"Mail/Local Folders\"\n        is part of the path. Finally, it initializes the mailbox using the `mailbox.mbox` method.\n\n        Raises:\n            ValueError: If the provided folder_path does not correspond to an existing file.\n        \"\"\"\n        self.tb = tb\n        # Convert relative path to absolute path if use_relative_path is True\n        if use_relative_path:\n            folder_path = os.path.join(tb.profile, \"Mail/Local Folders\", folder_path)\n\n        self.folder_path = folder_path\n\n        self.debug = debug\n        self.error = \"\"\n        if not os.path.isfile(folder_path):\n            msg = f\"{folder_path} does not exist\"\n            raise ValueError(msg)\n        self.folder_update_time = self.tb._get_file_update_time(self.folder_path)\n        self.relative_folder_path = ThunderbirdMailbox.as_relative_path(folder_path)\n        self.mbox = mailbox.mbox(folder_path)\n        if restore_toc and tb.index_db_exists():\n            self.restore_toc_from_sqldb(tb.index_db)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the ThunderbirdMailbox data to a dictionary for SQL database storage.\n\n        Returns:\n            Dict[str, Any]: The dictionary representation of the ThunderbirdMailbox.\n        \"\"\"\n        message_count = len(self.mbox)  # Assuming self.mbox is a mailbox object\n        return {\n            \"folder_path\": self.folder_path,\n            \"relative_folder_path\": self.relative_folder_path,\n            \"folder_update_time\": self.folder_update_time,\n            \"message_count\": message_count,\n            \"error\": str(self.error),\n        }\n\n    def as_view_record(self,index:int):\n        \"\"\"\n        return me as dict to view in a list of dicts grid\n        \"\"\"\n        return {\n            \"#\": index,\n            \"path\": self.relative_folder_path,\n            \"folder_update_time\": self.folder_update_time,\n            \"error\": str(self.error),\n        }\n\n    @staticmethod\n    def as_relative_path(folder_path: str) -&gt; str:\n        \"\"\"\n        convert the folder_path to a relative path\n\n        Args:\n            folder_path(str): the folder path to  convert\n\n        Returns:\n            str: the relative path\n        \"\"\"\n        # Check if \"Mail/Local Folders\" is in the folder path and split accordingly\n        if \"Mail/Local Folders\" in folder_path:\n            relative_folder_path = folder_path.split(\"Mail/Local Folders\")[-1]\n        else:\n            # If the specific string is not found, use the entire folder_path or handle as needed\n            relative_folder_path = folder_path\n        return relative_folder_path\n\n    def restore_toc_from_sqldb(self, sql_db: SQLDB) -&gt; None:\n        \"\"\"\n        Restore the table of contents from the given SQL database.\n\n        This method fetches the TOC data from the SQLite database and uses it to rebuild the TOC in the mailbox.\n\n        Args:\n            sql_db (SQLDB): An instance of SQLDB connected to the SQLite database.\n        \"\"\"\n        index_lod = self.get_toc_lod_from_sqldb(sql_db)\n        self.restore_toc_from_lod(index_lod)\n\n    def get_toc_lod_from_sqldb(self, sql_db: SQLDB) -&gt; list:\n        \"\"\"\n        Retrieve the index list of dictionaries (LoD) representing the TOC from the given SQL database.\n\n        This method performs a SQL query to fetch the TOC information, which includes the email index, start position,\n        and stop position for each email in the mailbox corresponding to the current folder path.\n\n        Args:\n            sql_db (SQLDB): An instance of SQLDB connected to the SQLite database.\n\n        Returns:\n            list: A list of dictionaries, each containing the index and TOC information for an email.\n        \"\"\"\n        sql_query = \"\"\"SELECT *\nFROM mail_index \nWHERE folder_path = ?\nORDER BY email_index\"\"\"\n        folder_path_param = (self.relative_folder_path,)\n        index_lod = sql_db.query(sql_query, folder_path_param)\n        return index_lod\n\n    @classmethod\n    def to_view_lod(\n        cls, index_lod: List[Dict[str, Any]], user: str\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Converts a list of index record dictionaries into a format suitable for display in an ag-grid.\n        It renames and repositions the 'email_index' key, removes 'start_pos' and 'stop_pos', and converts\n        'message_id' to a hyperlink using a custom Link.create() function.\n\n        Args:\n            index_lod (List[Dict[str, Any]]): A list of dictionaries representing the index records.\n            user (str): The user identifier to be used in constructing URLs for hyperlinks.\n\n        Returns:\n            List[Dict[str, Any]]: The list of modified index record dictionaries.\n        \"\"\"\n        for record in index_lod:\n            # HTML-encode potentially unsafe fields\n            for key in record:\n                if isinstance(record[key], str):\n                    record[key] = html.escape(record[key])\n\n            # Renaming and moving 'email_index' to the first position as '#'\n            record[\"#\"] = record.pop(\"email_index\") + 1\n\n            # Removing 'start_pos','stop_pos' and 'folder_path'\n            record.pop(\"start_pos\", None)\n            record.pop(\"stop_pos\", None)\n            record.pop(\"folder_path\", None)\n\n            # Converting 'message_id' to a hyperlink\n            mail_id = record[\"message_id\"]\n            normalized_mail_id = Mail.normalize_mailid(mail_id)\n            url = f\"/mail/{user}/{normalized_mail_id}\"\n            record[\"message_id\"] = Link.create(url, text=normalized_mail_id)\n\n        # Reordering keys to ensure '#' is first\n        sorted_index_lod = [\n            {k: record[k] for k in sorted(record, key=lambda x: x != \"#\")}\n            for record in index_lod\n        ]\n        return sorted_index_lod\n\n    def restore_toc_from_lod(self, index_lod: list) -&gt; None:\n        \"\"\"\n        Restores the table of contents of the mailbox using records from an SQLite database.\n\n        This method iterates over a list of dictionaries where each dictionary contains details about an email,\n        including its positions in the mailbox file. It uses this information to reconstruct the mailbox's TOC.\n\n        Args:\n            index_lod (list of dict): A list of records from the SQLite database. Each record is a dictionary\n                                      containing details about an email, including its positions in the mailbox file.\n        \"\"\"\n        # Reinitialize the mailbox's TOC structure\n        self.mbox._toc = {}\n\n        # Iterate over the index records to rebuild the TOC\n        for record in index_lod:\n            idx = record[\"email_index\"]\n            start_pos = record[\"start_pos\"]\n            stop_pos = record[\"stop_pos\"]\n\n            # Update the TOC with the new positions\n            self.mbox._toc[idx] = (start_pos, stop_pos)\n\n    def decode_subject(self, subject) -&gt; str:\n        # Decode the subject\n        decoded_bytes = decode_header(subject)\n        # Concatenate the decoded parts\n        decoded_subject = \"\".join(\n            str(text, charset or \"utf-8\") if isinstance(text, bytes) else text\n            for text, charset in decoded_bytes\n        )\n        return decoded_subject\n\n    def get_index_lod(self):\n        \"\"\"\n        get the list of dicts for indexing\n        \"\"\"\n        lod = []\n        for idx, message in enumerate(self.mbox):\n            start_pos, stop_pos = self.mbox._toc.get(idx, (None, None))\n            error_msg = \"\"  # Variable to store potential error messages\n            decoded_subject = \"?\"\n            msg_date, msg_iso_date, error_msg = Mail.get_iso_date(message)\n            try:\n                # Decode the subject\n                decoded_subject = self.decode_subject(message.get(\"Subject\", \"?\"))\n            except Exception as e:\n                error_msg = f\"{str(e)}\"\n\n            record = {\n                \"folder_path\": self.relative_folder_path,\n                \"message_id\": message.get(\n                    \"Message-ID\", f\"{self.relative_folder_path}#{idx}\"\n                ),\n                \"sender\": str(message.get(\"From\", \"?\")),\n                \"recipient\": str(message.get(\"To\", \"?\")),\n                \"subject\": decoded_subject,\n                \"date\": msg_date,\n                \"iso_date\": msg_iso_date,\n                \"email_index\": idx,\n                \"start_pos\": start_pos,\n                \"stop_pos\": stop_pos,\n                \"error\": error_msg,  # Add the error message if any\n            }\n            lod.append(record)\n\n        return lod\n\n    def get_message_by_key(self, messageKey: int) -&gt; Message:\n        \"\"\"\n        Retrieves the email message by its message key.\n\n        This method fetches an email message based on its unique message key from the mbox mailbox file. It uses the\n        `messageKey` to index into the mbox file and retrieve the specific message. The method profiles the time taken\n        to fetch the message using the `Profiler` utility class for performance monitoring.\n\n        Args:\n            messageKey (int): The unique key (index) of the email message to be retrieved.\n\n        Returns:\n            Message: The email message object corresponding to the specified message key.\n\n        Note:\n            The `messageKey` is assumed to be 1-based when passed to this function, but the `mailbox.mbox` class uses\n            0-based indexing, so 1 is subtracted from `messageKey` for internal use.\n        \"\"\"\n        getTime = Profiler(\n            f\"mbox.get {messageKey-1} from {self.folder_path}\", profile=self.debug\n        )\n        msg = self.mbox.get(messageKey - 1)\n        getTime.time()\n        return msg\n\n    def get_message_by_pos(self, start_pos: int, stop_pos: int) -&gt; Optional[Message]:\n        \"\"\"\n        Fetches an email message by its start and stop byte positions in the mailbox file\n        and parses it into an email.message.Message object.\n\n        Args:\n            start_pos (int): The starting byte position of the message in the mailbox file.\n            stop_pos (int): The stopping byte position of the message in the mailbox file.\n\n        Returns:\n            Message: The email message object parsed from the specified byte range,\n        Raises:\n            FileNotFoundError: If the mailbox file does not exist.\n            IOError: If an error occurs during file opening or reading.\n            ValueError: If the byte range does not represent a valid email message.\n\n        \"\"\"\n        with open(self.folder_path, 'rb') as mbox_file:\n            mbox_file.seek(start_pos)  # Move to the start position\n            content = mbox_file.read(stop_pos - start_pos)  # Read the specified range\n\n            # Parse the content into an email.message.Message object\n            msg = message_from_bytes(content)\n            return msg\n\n    def search_message_by_key(self, mailid: str):\n        \"\"\"\n        search messages by key\n        \"\"\"\n        msg = None\n        searchId = f\"&lt;{mailid}&gt;\"\n        searchTime = Profiler(\n            f\"keySearch {searchId} after mbox.get failed\", profile=self.debug\n        )\n        for key in self.mbox.keys():\n            keyMsg = self.mbox.get(key)\n            msgId = keyMsg.get(\"Message-Id\")\n            if msgId == searchId:\n                msg = keyMsg\n                break\n            pass\n        searchTime.time()\n        return msg\n\n    def close(self):\n        \"\"\"\n        close the mailbox\n        \"\"\"\n        self.mbox.close()\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.__init__","title":"<code>__init__(tb, folder_path, use_relative_path=False, restore_toc=True, debug=False)</code>","text":"<p>Initializes a new Mailbox object associated with a specific Thunderbird email client and mailbox folder.</p> <p>Parameters:</p> Name Type Description Default <code>tb</code> <code>Thunderbird</code> <p>An instance of the Thunderbird class representing the email client to which this mailbox belongs.</p> required <code>folder_path</code> <code>str</code> <p>The file system path to the mailbox folder.</p> required <code>use_relative_path</code> <code>bool</code> <p>If True, use a relative path for the mailbox folder. Default is False.</p> <code>False</code> <code>restore_toc(bool)</code> <p>If True restore the table of contents</p> required <code>debug</code> <code>bool</code> <p>A flag for enabling debug mode. Default is False.</p> <code>False</code> <p>The constructor sets the Thunderbird instance, folder path, and debug flag. It checks if the provided folder_path is a valid file and raises a ValueError if it does not exist. The method also handles the extraction of the relative folder path from the provided folder_path, especially handling the case where \"Mail/Local Folders\" is part of the path. Finally, it initializes the mailbox using the <code>mailbox.mbox</code> method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided folder_path does not correspond to an existing file.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def __init__(\n    self,\n    tb: Thunderbird,\n    folder_path: str,\n    use_relative_path: bool = False,\n    restore_toc: bool = True,\n    debug: bool = False,\n):\n    \"\"\"\n    Initializes a new Mailbox object associated with a specific Thunderbird email client and mailbox folder.\n\n    Args:\n        tb (Thunderbird): An instance of the Thunderbird class representing the email client to which this mailbox belongs.\n        folder_path (str): The file system path to the mailbox folder.\n        use_relative_path (bool): If True, use a relative path for the mailbox folder. Default is False.\n        restore_toc(bool): If True restore the table of contents\n        debug (bool, optional): A flag for enabling debug mode. Default is False.\n\n    The constructor sets the Thunderbird instance, folder path, and debug flag. It checks if the provided folder_path\n    is a valid file and raises a ValueError if it does not exist. The method also handles the extraction of\n    the relative folder path from the provided folder_path, especially handling the case where \"Mail/Local Folders\"\n    is part of the path. Finally, it initializes the mailbox using the `mailbox.mbox` method.\n\n    Raises:\n        ValueError: If the provided folder_path does not correspond to an existing file.\n    \"\"\"\n    self.tb = tb\n    # Convert relative path to absolute path if use_relative_path is True\n    if use_relative_path:\n        folder_path = os.path.join(tb.profile, \"Mail/Local Folders\", folder_path)\n\n    self.folder_path = folder_path\n\n    self.debug = debug\n    self.error = \"\"\n    if not os.path.isfile(folder_path):\n        msg = f\"{folder_path} does not exist\"\n        raise ValueError(msg)\n    self.folder_update_time = self.tb._get_file_update_time(self.folder_path)\n    self.relative_folder_path = ThunderbirdMailbox.as_relative_path(folder_path)\n    self.mbox = mailbox.mbox(folder_path)\n    if restore_toc and tb.index_db_exists():\n        self.restore_toc_from_sqldb(tb.index_db)\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.as_relative_path","title":"<code>as_relative_path(folder_path)</code>  <code>staticmethod</code>","text":"<p>convert the folder_path to a relative path</p> <p>Parameters:</p> Name Type Description Default <code>folder_path(str)</code> <p>the folder path to  convert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the relative path</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@staticmethod\ndef as_relative_path(folder_path: str) -&gt; str:\n    \"\"\"\n    convert the folder_path to a relative path\n\n    Args:\n        folder_path(str): the folder path to  convert\n\n    Returns:\n        str: the relative path\n    \"\"\"\n    # Check if \"Mail/Local Folders\" is in the folder path and split accordingly\n    if \"Mail/Local Folders\" in folder_path:\n        relative_folder_path = folder_path.split(\"Mail/Local Folders\")[-1]\n    else:\n        # If the specific string is not found, use the entire folder_path or handle as needed\n        relative_folder_path = folder_path\n    return relative_folder_path\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.as_view_record","title":"<code>as_view_record(index)</code>","text":"<p>return me as dict to view in a list of dicts grid</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def as_view_record(self,index:int):\n    \"\"\"\n    return me as dict to view in a list of dicts grid\n    \"\"\"\n    return {\n        \"#\": index,\n        \"path\": self.relative_folder_path,\n        \"folder_update_time\": self.folder_update_time,\n        \"error\": str(self.error),\n    }\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.close","title":"<code>close()</code>","text":"<p>close the mailbox</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def close(self):\n    \"\"\"\n    close the mailbox\n    \"\"\"\n    self.mbox.close()\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.get_index_lod","title":"<code>get_index_lod()</code>","text":"<p>get the list of dicts for indexing</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_index_lod(self):\n    \"\"\"\n    get the list of dicts for indexing\n    \"\"\"\n    lod = []\n    for idx, message in enumerate(self.mbox):\n        start_pos, stop_pos = self.mbox._toc.get(idx, (None, None))\n        error_msg = \"\"  # Variable to store potential error messages\n        decoded_subject = \"?\"\n        msg_date, msg_iso_date, error_msg = Mail.get_iso_date(message)\n        try:\n            # Decode the subject\n            decoded_subject = self.decode_subject(message.get(\"Subject\", \"?\"))\n        except Exception as e:\n            error_msg = f\"{str(e)}\"\n\n        record = {\n            \"folder_path\": self.relative_folder_path,\n            \"message_id\": message.get(\n                \"Message-ID\", f\"{self.relative_folder_path}#{idx}\"\n            ),\n            \"sender\": str(message.get(\"From\", \"?\")),\n            \"recipient\": str(message.get(\"To\", \"?\")),\n            \"subject\": decoded_subject,\n            \"date\": msg_date,\n            \"iso_date\": msg_iso_date,\n            \"email_index\": idx,\n            \"start_pos\": start_pos,\n            \"stop_pos\": stop_pos,\n            \"error\": error_msg,  # Add the error message if any\n        }\n        lod.append(record)\n\n    return lod\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.get_message_by_key","title":"<code>get_message_by_key(messageKey)</code>","text":"<p>Retrieves the email message by its message key.</p> <p>This method fetches an email message based on its unique message key from the mbox mailbox file. It uses the <code>messageKey</code> to index into the mbox file and retrieve the specific message. The method profiles the time taken to fetch the message using the <code>Profiler</code> utility class for performance monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>messageKey</code> <code>int</code> <p>The unique key (index) of the email message to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The email message object corresponding to the specified message key.</p> Note <p>The <code>messageKey</code> is assumed to be 1-based when passed to this function, but the <code>mailbox.mbox</code> class uses 0-based indexing, so 1 is subtracted from <code>messageKey</code> for internal use.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_message_by_key(self, messageKey: int) -&gt; Message:\n    \"\"\"\n    Retrieves the email message by its message key.\n\n    This method fetches an email message based on its unique message key from the mbox mailbox file. It uses the\n    `messageKey` to index into the mbox file and retrieve the specific message. The method profiles the time taken\n    to fetch the message using the `Profiler` utility class for performance monitoring.\n\n    Args:\n        messageKey (int): The unique key (index) of the email message to be retrieved.\n\n    Returns:\n        Message: The email message object corresponding to the specified message key.\n\n    Note:\n        The `messageKey` is assumed to be 1-based when passed to this function, but the `mailbox.mbox` class uses\n        0-based indexing, so 1 is subtracted from `messageKey` for internal use.\n    \"\"\"\n    getTime = Profiler(\n        f\"mbox.get {messageKey-1} from {self.folder_path}\", profile=self.debug\n    )\n    msg = self.mbox.get(messageKey - 1)\n    getTime.time()\n    return msg\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.get_message_by_pos","title":"<code>get_message_by_pos(start_pos, stop_pos)</code>","text":"<p>Fetches an email message by its start and stop byte positions in the mailbox file and parses it into an email.message.Message object.</p> <p>Parameters:</p> Name Type Description Default <code>start_pos</code> <code>int</code> <p>The starting byte position of the message in the mailbox file.</p> required <code>stop_pos</code> <code>int</code> <p>The stopping byte position of the message in the mailbox file.</p> required <p>Returns:</p> Name Type Description <code>Message</code> <code>Optional[Message]</code> <p>The email message object parsed from the specified byte range,</p> <p>Raises:     FileNotFoundError: If the mailbox file does not exist.     IOError: If an error occurs during file opening or reading.     ValueError: If the byte range does not represent a valid email message.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def get_message_by_pos(self, start_pos: int, stop_pos: int) -&gt; Optional[Message]:\n    \"\"\"\n    Fetches an email message by its start and stop byte positions in the mailbox file\n    and parses it into an email.message.Message object.\n\n    Args:\n        start_pos (int): The starting byte position of the message in the mailbox file.\n        stop_pos (int): The stopping byte position of the message in the mailbox file.\n\n    Returns:\n        Message: The email message object parsed from the specified byte range,\n    Raises:\n        FileNotFoundError: If the mailbox file does not exist.\n        IOError: If an error occurs during file opening or reading.\n        ValueError: If the byte range does not represent a valid email message.\n\n    \"\"\"\n    with open(self.folder_path, 'rb') as mbox_file:\n        mbox_file.seek(start_pos)  # Move to the start position\n        content = mbox_file.read(stop_pos - start_pos)  # Read the specified range\n\n        # Parse the content into an email.message.Message object\n        msg = message_from_bytes(content)\n        return msg\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.get_toc_lod_from_sqldb","title":"<code>get_toc_lod_from_sqldb(sql_db)</code>","text":"<p>Retrieve the index list of dictionaries (LoD) representing the TOC from the given SQL database.</p> <p>This method performs a SQL query to fetch the TOC information, which includes the email index, start position, and stop position for each email in the mailbox corresponding to the current folder path.</p> <p>Parameters:</p> Name Type Description Default <code>sql_db</code> <code>SQLDB</code> <p>An instance of SQLDB connected to the SQLite database.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of dictionaries, each containing the index and TOC information for an email.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>    def get_toc_lod_from_sqldb(self, sql_db: SQLDB) -&gt; list:\n        \"\"\"\n        Retrieve the index list of dictionaries (LoD) representing the TOC from the given SQL database.\n\n        This method performs a SQL query to fetch the TOC information, which includes the email index, start position,\n        and stop position for each email in the mailbox corresponding to the current folder path.\n\n        Args:\n            sql_db (SQLDB): An instance of SQLDB connected to the SQLite database.\n\n        Returns:\n            list: A list of dictionaries, each containing the index and TOC information for an email.\n        \"\"\"\n        sql_query = \"\"\"SELECT *\nFROM mail_index \nWHERE folder_path = ?\nORDER BY email_index\"\"\"\n        folder_path_param = (self.relative_folder_path,)\n        index_lod = sql_db.query(sql_query, folder_path_param)\n        return index_lod\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.restore_toc_from_lod","title":"<code>restore_toc_from_lod(index_lod)</code>","text":"<p>Restores the table of contents of the mailbox using records from an SQLite database.</p> <p>This method iterates over a list of dictionaries where each dictionary contains details about an email, including its positions in the mailbox file. It uses this information to reconstruct the mailbox's TOC.</p> <p>Parameters:</p> Name Type Description Default <code>index_lod</code> <code>list of dict</code> <p>A list of records from the SQLite database. Each record is a dictionary                       containing details about an email, including its positions in the mailbox file.</p> required Source code in <code>thunderbird/mail.py</code> <pre><code>def restore_toc_from_lod(self, index_lod: list) -&gt; None:\n    \"\"\"\n    Restores the table of contents of the mailbox using records from an SQLite database.\n\n    This method iterates over a list of dictionaries where each dictionary contains details about an email,\n    including its positions in the mailbox file. It uses this information to reconstruct the mailbox's TOC.\n\n    Args:\n        index_lod (list of dict): A list of records from the SQLite database. Each record is a dictionary\n                                  containing details about an email, including its positions in the mailbox file.\n    \"\"\"\n    # Reinitialize the mailbox's TOC structure\n    self.mbox._toc = {}\n\n    # Iterate over the index records to rebuild the TOC\n    for record in index_lod:\n        idx = record[\"email_index\"]\n        start_pos = record[\"start_pos\"]\n        stop_pos = record[\"stop_pos\"]\n\n        # Update the TOC with the new positions\n        self.mbox._toc[idx] = (start_pos, stop_pos)\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.restore_toc_from_sqldb","title":"<code>restore_toc_from_sqldb(sql_db)</code>","text":"<p>Restore the table of contents from the given SQL database.</p> <p>This method fetches the TOC data from the SQLite database and uses it to rebuild the TOC in the mailbox.</p> <p>Parameters:</p> Name Type Description Default <code>sql_db</code> <code>SQLDB</code> <p>An instance of SQLDB connected to the SQLite database.</p> required Source code in <code>thunderbird/mail.py</code> <pre><code>def restore_toc_from_sqldb(self, sql_db: SQLDB) -&gt; None:\n    \"\"\"\n    Restore the table of contents from the given SQL database.\n\n    This method fetches the TOC data from the SQLite database and uses it to rebuild the TOC in the mailbox.\n\n    Args:\n        sql_db (SQLDB): An instance of SQLDB connected to the SQLite database.\n    \"\"\"\n    index_lod = self.get_toc_lod_from_sqldb(sql_db)\n    self.restore_toc_from_lod(index_lod)\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.search_message_by_key","title":"<code>search_message_by_key(mailid)</code>","text":"<p>search messages by key</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def search_message_by_key(self, mailid: str):\n    \"\"\"\n    search messages by key\n    \"\"\"\n    msg = None\n    searchId = f\"&lt;{mailid}&gt;\"\n    searchTime = Profiler(\n        f\"keySearch {searchId} after mbox.get failed\", profile=self.debug\n    )\n    for key in self.mbox.keys():\n        keyMsg = self.mbox.get(key)\n        msgId = keyMsg.get(\"Message-Id\")\n        if msgId == searchId:\n            msg = keyMsg\n            break\n        pass\n    searchTime.time()\n    return msg\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the ThunderbirdMailbox data to a dictionary for SQL database storage.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The dictionary representation of the ThunderbirdMailbox.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the ThunderbirdMailbox data to a dictionary for SQL database storage.\n\n    Returns:\n        Dict[str, Any]: The dictionary representation of the ThunderbirdMailbox.\n    \"\"\"\n    message_count = len(self.mbox)  # Assuming self.mbox is a mailbox object\n    return {\n        \"folder_path\": self.folder_path,\n        \"relative_folder_path\": self.relative_folder_path,\n        \"folder_update_time\": self.folder_update_time,\n        \"message_count\": message_count,\n        \"error\": str(self.error),\n    }\n</code></pre>"},{"location":"#thunderbird.mail.ThunderbirdMailbox.to_view_lod","title":"<code>to_view_lod(index_lod, user)</code>  <code>classmethod</code>","text":"<p>Converts a list of index record dictionaries into a format suitable for display in an ag-grid. It renames and repositions the 'email_index' key, removes 'start_pos' and 'stop_pos', and converts 'message_id' to a hyperlink using a custom Link.create() function.</p> <p>Parameters:</p> Name Type Description Default <code>index_lod</code> <code>List[Dict[str, Any]]</code> <p>A list of dictionaries representing the index records.</p> required <code>user</code> <code>str</code> <p>The user identifier to be used in constructing URLs for hyperlinks.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: The list of modified index record dictionaries.</p> Source code in <code>thunderbird/mail.py</code> <pre><code>@classmethod\ndef to_view_lod(\n    cls, index_lod: List[Dict[str, Any]], user: str\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Converts a list of index record dictionaries into a format suitable for display in an ag-grid.\n    It renames and repositions the 'email_index' key, removes 'start_pos' and 'stop_pos', and converts\n    'message_id' to a hyperlink using a custom Link.create() function.\n\n    Args:\n        index_lod (List[Dict[str, Any]]): A list of dictionaries representing the index records.\n        user (str): The user identifier to be used in constructing URLs for hyperlinks.\n\n    Returns:\n        List[Dict[str, Any]]: The list of modified index record dictionaries.\n    \"\"\"\n    for record in index_lod:\n        # HTML-encode potentially unsafe fields\n        for key in record:\n            if isinstance(record[key], str):\n                record[key] = html.escape(record[key])\n\n        # Renaming and moving 'email_index' to the first position as '#'\n        record[\"#\"] = record.pop(\"email_index\") + 1\n\n        # Removing 'start_pos','stop_pos' and 'folder_path'\n        record.pop(\"start_pos\", None)\n        record.pop(\"stop_pos\", None)\n        record.pop(\"folder_path\", None)\n\n        # Converting 'message_id' to a hyperlink\n        mail_id = record[\"message_id\"]\n        normalized_mail_id = Mail.normalize_mailid(mail_id)\n        url = f\"/mail/{user}/{normalized_mail_id}\"\n        record[\"message_id\"] = Link.create(url, text=normalized_mail_id)\n\n    # Reordering keys to ensure '#' is first\n    sorted_index_lod = [\n        {k: record[k] for k in sorted(record, key=lambda x: x != \"#\")}\n        for record in index_lod\n    ]\n    return sorted_index_lod\n</code></pre>"},{"location":"#thunderbird.mail_cmd","title":"<code>mail_cmd</code>","text":"<p>Created on 2023-11-23</p> <p>@author: wf</p>"},{"location":"#thunderbird.mail_cmd.ThunderbirdMailCmd","title":"<code>ThunderbirdMailCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>command line access to pyThunderbird</p> Source code in <code>thunderbird/mail_cmd.py</code> <pre><code>class ThunderbirdMailCmd(WebserverCmd):\n    \"\"\"\n    command line access to pyThunderbird\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\"-u\", \"--user\", type=str, help=\"id of the user\")\n        parser.add_argument(\n            \"-m\", \"--mailid\", type=str, help=\"id of the mail to retrieve\"\n        )\n        parser.add_argument(\"-ul\", \"--user-list\", default=[], nargs=\"+\")\n        parser.add_argument(\n            \"-ci\",\n            \"--create-index\",\n            action=\"store_true\",\n            help=\"create an alternative index for the given users's Thunderbird mailarchive\",\n        )\n        parser.add_argument(\n            \"-cil\",\n            \"--create-index-list\",\n            default=[],\n            nargs=\"+\",\n            help=\"create an alternative index for the given list of relative mailbox paths\",\n        )\n        parser.add_argument(\n            \"-f\",\n            \"--force\",\n            action=\"store_true\",\n            help=\"force the creation of a new index even if one already exists\",\n        )\n        parser.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_true\",\n            help=\"show verbose infos e.g. on startup [default: %(default)s]\",\n        )\n        return parser\n\n    def handle_args(self) -&gt; bool:\n        \"\"\"\n        Handles command line arguments.\n\n        This method processes the command line arguments provided to the script.\n        It checks for the presence of required arguments and initializes the Mail object\n        if the necessary arguments are provided.\n\n        Returns:\n            bool: True if the arguments are processed successfully, False otherwise.\n        \"\"\"\n        # Calling the superclass constructor or method, if needed\n        super().handle_args()\n\n        args = self.args\n\n        # Check if both user and id arguments are provided\n        if args.user is None:\n            if args.mailid is None and not args.create_index:\n                self.parser.print_help()\n                return False\n        elif args.create_index:\n            tb = Thunderbird.get(args.user)\n            indexing_state = tb.create_or_update_index(force_create=args.force)\n            indexing_state.show_index_report(verbose=args.verbose)\n        elif args.create_index_list:\n            tb = Thunderbird.get(args.user)\n            indexing_state = tb.create_or_update_index(\n                force_create=args.force, relative_paths=args.create_index_list\n            )\n            indexing_state.show_index_report(verbose=args.verbose)\n        elif args.mailid:\n            # Creating a Mail object with the provided arguments\n            mail = Mail(user=args.user, mailid=args.mailid, debug=args.debug)\n            if mail.found:\n                print(mail.msg)\n                return True\n            else:\n                msg = f\"mail with id {args.mailid} for user {args.user} not found\"\n                print(msg, files=sys.stderr)\n                self.exit_code = 1\n</code></pre>"},{"location":"#thunderbird.mail_cmd.ThunderbirdMailCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>thunderbird/mail_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\"-u\", \"--user\", type=str, help=\"id of the user\")\n    parser.add_argument(\n        \"-m\", \"--mailid\", type=str, help=\"id of the mail to retrieve\"\n    )\n    parser.add_argument(\"-ul\", \"--user-list\", default=[], nargs=\"+\")\n    parser.add_argument(\n        \"-ci\",\n        \"--create-index\",\n        action=\"store_true\",\n        help=\"create an alternative index for the given users's Thunderbird mailarchive\",\n    )\n    parser.add_argument(\n        \"-cil\",\n        \"--create-index-list\",\n        default=[],\n        nargs=\"+\",\n        help=\"create an alternative index for the given list of relative mailbox paths\",\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--force\",\n        action=\"store_true\",\n        help=\"force the creation of a new index even if one already exists\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"show verbose infos e.g. on startup [default: %(default)s]\",\n    )\n    return parser\n</code></pre>"},{"location":"#thunderbird.mail_cmd.ThunderbirdMailCmd.handle_args","title":"<code>handle_args()</code>","text":"<p>Handles command line arguments.</p> <p>This method processes the command line arguments provided to the script. It checks for the presence of required arguments and initializes the Mail object if the necessary arguments are provided.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the arguments are processed successfully, False otherwise.</p> Source code in <code>thunderbird/mail_cmd.py</code> <pre><code>def handle_args(self) -&gt; bool:\n    \"\"\"\n    Handles command line arguments.\n\n    This method processes the command line arguments provided to the script.\n    It checks for the presence of required arguments and initializes the Mail object\n    if the necessary arguments are provided.\n\n    Returns:\n        bool: True if the arguments are processed successfully, False otherwise.\n    \"\"\"\n    # Calling the superclass constructor or method, if needed\n    super().handle_args()\n\n    args = self.args\n\n    # Check if both user and id arguments are provided\n    if args.user is None:\n        if args.mailid is None and not args.create_index:\n            self.parser.print_help()\n            return False\n    elif args.create_index:\n        tb = Thunderbird.get(args.user)\n        indexing_state = tb.create_or_update_index(force_create=args.force)\n        indexing_state.show_index_report(verbose=args.verbose)\n    elif args.create_index_list:\n        tb = Thunderbird.get(args.user)\n        indexing_state = tb.create_or_update_index(\n            force_create=args.force, relative_paths=args.create_index_list\n        )\n        indexing_state.show_index_report(verbose=args.verbose)\n    elif args.mailid:\n        # Creating a Mail object with the provided arguments\n        mail = Mail(user=args.user, mailid=args.mailid, debug=args.debug)\n        if mail.found:\n            print(mail.msg)\n            return True\n        else:\n            msg = f\"mail with id {args.mailid} for user {args.user} not found\"\n            print(msg, files=sys.stderr)\n            self.exit_code = 1\n</code></pre>"},{"location":"#thunderbird.mail_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>thunderbird/mail_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = ThunderbirdMailCmd(\n        config=ThunderbirdWebserver.get_config(), webserver_cls=ThunderbirdWebserver\n    )\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#thunderbird.profiler","title":"<code>profiler</code>","text":"<p>Created on 2021-10-15</p> <p>@author: wf</p>"},{"location":"#thunderbird.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>thunderbird/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg, profile=True):\n        \"\"\"\n        construct me with the given msg and profile active flag\n\n        Args:\n            msg(str): the message to show if profiling is active\n            profile(bool): True if messages should be shown\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        self.starttime = time.time()\n        if profile:\n            print(f\"Starting {msg} ...\")\n\n    def time(self, extraMsg=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#thunderbird.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True)</code>","text":"<p>construct me with the given msg and profile active flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to show if profiling is active</p> required <code>profile(bool)</code> <p>True if messages should be shown</p> required Source code in <code>thunderbird/profiler.py</code> <pre><code>def __init__(self, msg, profile=True):\n    \"\"\"\n    construct me with the given msg and profile active flag\n\n    Args:\n        msg(str): the message to show if profiling is active\n        profile(bool): True if messages should be shown\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    self.starttime = time.time()\n    if profile:\n        print(f\"Starting {msg} ...\")\n</code></pre>"},{"location":"#thunderbird.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>thunderbird/profiler.py</code> <pre><code>def time(self, extraMsg=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#thunderbird.search","title":"<code>search</code>","text":"<p>Created on 2023-12-06</p> <p>@author: wf</p>"},{"location":"#thunderbird.search.MailSearch","title":"<code>MailSearch</code>","text":"<p>utility module to search Thunderbird mails https://github.com/WolfgangFahl/pyThunderbird/issues/15</p> Source code in <code>thunderbird/search.py</code> <pre><code>class MailSearch:\n    \"\"\"\n    utility module to search Thunderbird mails\n    https://github.com/WolfgangFahl/pyThunderbird/issues/15\n    \"\"\"\n\n    def __init__(\n        self,\n        webserver,\n        tb,\n        search_dict: dict,\n        with_ui: bool = True,\n        result_limit: int = 1000,\n    ):\n        \"\"\"\n        Constructor.\n\n        Args:\n            webserver: The webserver instance.\n            tb: The Thunderbird instance.\n            search_dict (dict): The dictionary containing search parameters.\n            result_limit(int): maximum number of mails to be displayed\n            with_ui (bool): If True, sets up the UI components.\n        \"\"\"\n        self.webserver = webserver\n        self.tb = tb\n        self.result_limit = result_limit\n        if with_ui:\n            self.setup_form(search_dict)\n\n    def setup_form(self, search_dict: dict):\n        \"\"\"\n        Set up a search form.\n\n        Args:\n            search_dict (dict): The dictionary containing search parameters.\n        \"\"\"\n        self.dict_edit = DictEdit(search_dict)\n        self.dict_edit.expansion.open()\n        self.search_button = (\n            ui.button(\"search\", icon=\"search\", color=\"primary\")\n            .tooltip(\"search thunderbird mails\")\n            .on(\"click\", handler=self.on_search)\n        )\n        self.search_summary = ui.html()\n        self.search_results_grid = ListOfDictsGrid(lod=[])\n\n    def construct_query(self, search_criteria: dict) -&gt; (str, list):\n        \"\"\"\n            Construct the SQL query based on the search criteria.\n\n            Args:\n                search_criteria (dict): The dictionary containing search parameters.\n\n            Returns:\n                tuple: A tuple containing the SQL query string and the list of parameters.\n\n           The search is based on the `index_db` table structure:\n\n        CREATE TABLE mail_index (\n          folder_path TEXT,\n          message_id TEXT,\n          sender TEXT,\n          recipient TEXT,\n          subject TEXT,\n          date TEXT,\n          iso_date TEXT,\n          email_index INTEGER,\n          start_pos INTEGER,\n          stop_pos INTEGER,\n          error TEXT\n        )\n        \"\"\"\n        sql_query = \"SELECT * FROM mail_index WHERE \"\n        query_conditions = []\n        query_params = []\n\n        # Mapping from search_dict keys to SQL table columns\n        column_mappings = {\n            \"Subject\": \"subject\",\n            \"From\": \"sender\",\n            \"To\": \"recipient\",\n            \"Message-ID:\": \"message_id\",\n        }\n\n        for field, value in search_criteria.items():\n            if value and column_mappings[field]:\n                sql_column = column_mappings[field]\n                query_conditions.append(f\"{sql_column} LIKE ?\")\n                query_params.append(f\"%{value}%\")\n\n        # Special handling for fields like \"Content\" or \"Date\" can be added here\n\n        if not query_conditions:\n            sql_query = \"SELECT * FROM mail_index\"\n        else:\n            sql_query += \" AND \".join(query_conditions)\n\n        return sql_query, query_params\n\n    async def on_search(self, _event: GenericEventArguments):\n        \"\"\"\n        Handle the search based on the search form criteria.\n\n        Args:\n            event (GenericEventArguments): Event arguments (unused in this method).\n        \"\"\"\n        try:\n            search_criteria = self.dict_edit.d\n            sql_query, query_params = self.construct_query(search_criteria)\n            search_results = self.tb.index_db.query(sql_query, query_params)\n            result_count = len(search_results)\n            msg = f\"{result_count} messages found\"\n            if result_count &gt; self.result_limit:\n                msg = f\"too many results: {result_count}&gt;{self.result_limit}\"\n            self.search_summary.content = msg\n            search_results = search_results[: self.result_limit]\n            view_lod = ThunderbirdMailbox.to_view_lod(search_results, user=self.tb.user)\n\n            self.search_results_grid.load_lod(view_lod)\n            self.search_results_grid.update()\n        except Exception as ex:\n            self.webserver.handle_exception(ex)\n</code></pre>"},{"location":"#thunderbird.search.MailSearch.__init__","title":"<code>__init__(webserver, tb, search_dict, with_ui=True, result_limit=1000)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>webserver</code> <p>The webserver instance.</p> required <code>tb</code> <p>The Thunderbird instance.</p> required <code>search_dict</code> <code>dict</code> <p>The dictionary containing search parameters.</p> required <code>result_limit(int)</code> <p>maximum number of mails to be displayed</p> required <code>with_ui</code> <code>bool</code> <p>If True, sets up the UI components.</p> <code>True</code> Source code in <code>thunderbird/search.py</code> <pre><code>def __init__(\n    self,\n    webserver,\n    tb,\n    search_dict: dict,\n    with_ui: bool = True,\n    result_limit: int = 1000,\n):\n    \"\"\"\n    Constructor.\n\n    Args:\n        webserver: The webserver instance.\n        tb: The Thunderbird instance.\n        search_dict (dict): The dictionary containing search parameters.\n        result_limit(int): maximum number of mails to be displayed\n        with_ui (bool): If True, sets up the UI components.\n    \"\"\"\n    self.webserver = webserver\n    self.tb = tb\n    self.result_limit = result_limit\n    if with_ui:\n        self.setup_form(search_dict)\n</code></pre>"},{"location":"#thunderbird.search.MailSearch.construct_query","title":"<code>construct_query(search_criteria)</code>","text":"<pre><code>Construct the SQL query based on the search criteria.\n\nArgs:\n    search_criteria (dict): The dictionary containing search parameters.\n\nReturns:\n    tuple: A tuple containing the SQL query string and the list of parameters.\n</code></pre> <p>The search is based on the <code>index_db</code> table structure:</p> <p>CREATE TABLE mail_index (   folder_path TEXT,   message_id TEXT,   sender TEXT,   recipient TEXT,   subject TEXT,   date TEXT,   iso_date TEXT,   email_index INTEGER,   start_pos INTEGER,   stop_pos INTEGER,   error TEXT )</p> Source code in <code>thunderbird/search.py</code> <pre><code>def construct_query(self, search_criteria: dict) -&gt; (str, list):\n    \"\"\"\n        Construct the SQL query based on the search criteria.\n\n        Args:\n            search_criteria (dict): The dictionary containing search parameters.\n\n        Returns:\n            tuple: A tuple containing the SQL query string and the list of parameters.\n\n       The search is based on the `index_db` table structure:\n\n    CREATE TABLE mail_index (\n      folder_path TEXT,\n      message_id TEXT,\n      sender TEXT,\n      recipient TEXT,\n      subject TEXT,\n      date TEXT,\n      iso_date TEXT,\n      email_index INTEGER,\n      start_pos INTEGER,\n      stop_pos INTEGER,\n      error TEXT\n    )\n    \"\"\"\n    sql_query = \"SELECT * FROM mail_index WHERE \"\n    query_conditions = []\n    query_params = []\n\n    # Mapping from search_dict keys to SQL table columns\n    column_mappings = {\n        \"Subject\": \"subject\",\n        \"From\": \"sender\",\n        \"To\": \"recipient\",\n        \"Message-ID:\": \"message_id\",\n    }\n\n    for field, value in search_criteria.items():\n        if value and column_mappings[field]:\n            sql_column = column_mappings[field]\n            query_conditions.append(f\"{sql_column} LIKE ?\")\n            query_params.append(f\"%{value}%\")\n\n    # Special handling for fields like \"Content\" or \"Date\" can be added here\n\n    if not query_conditions:\n        sql_query = \"SELECT * FROM mail_index\"\n    else:\n        sql_query += \" AND \".join(query_conditions)\n\n    return sql_query, query_params\n</code></pre>"},{"location":"#thunderbird.search.MailSearch.on_search","title":"<code>on_search(_event)</code>  <code>async</code>","text":"<p>Handle the search based on the search form criteria.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>GenericEventArguments</code> <p>Event arguments (unused in this method).</p> required Source code in <code>thunderbird/search.py</code> <pre><code>async def on_search(self, _event: GenericEventArguments):\n    \"\"\"\n    Handle the search based on the search form criteria.\n\n    Args:\n        event (GenericEventArguments): Event arguments (unused in this method).\n    \"\"\"\n    try:\n        search_criteria = self.dict_edit.d\n        sql_query, query_params = self.construct_query(search_criteria)\n        search_results = self.tb.index_db.query(sql_query, query_params)\n        result_count = len(search_results)\n        msg = f\"{result_count} messages found\"\n        if result_count &gt; self.result_limit:\n            msg = f\"too many results: {result_count}&gt;{self.result_limit}\"\n        self.search_summary.content = msg\n        search_results = search_results[: self.result_limit]\n        view_lod = ThunderbirdMailbox.to_view_lod(search_results, user=self.tb.user)\n\n        self.search_results_grid.load_lod(view_lod)\n        self.search_results_grid.update()\n    except Exception as ex:\n        self.webserver.handle_exception(ex)\n</code></pre>"},{"location":"#thunderbird.search.MailSearch.setup_form","title":"<code>setup_form(search_dict)</code>","text":"<p>Set up a search form.</p> <p>Parameters:</p> Name Type Description Default <code>search_dict</code> <code>dict</code> <p>The dictionary containing search parameters.</p> required Source code in <code>thunderbird/search.py</code> <pre><code>def setup_form(self, search_dict: dict):\n    \"\"\"\n    Set up a search form.\n\n    Args:\n        search_dict (dict): The dictionary containing search parameters.\n    \"\"\"\n    self.dict_edit = DictEdit(search_dict)\n    self.dict_edit.expansion.open()\n    self.search_button = (\n        ui.button(\"search\", icon=\"search\", color=\"primary\")\n        .tooltip(\"search thunderbird mails\")\n        .on(\"click\", handler=self.on_search)\n    )\n    self.search_summary = ui.html()\n    self.search_results_grid = ListOfDictsGrid(lod=[])\n</code></pre>"},{"location":"#thunderbird.tb_webserver","title":"<code>tb_webserver</code>","text":"<p>Created on 2023-11-23</p> <p>@author: wf</p>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution","title":"<code>ThunderbirdSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the Thunderbird Mail solution</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>class ThunderbirdSolution(InputWebSolution):\n    \"\"\"\n    the Thunderbird Mail solution\n    \"\"\"\n\n    def __init__(self, webserver: ThunderbirdWebserver, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (DynamicCompotenceMapWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.tb = None\n        self.mail_archives=self.webserver.mail_archives\n\n    async def show_mailboxes(self, user: str, profile_key: str):\n        \"\"\"\n        Shows a mailboxes for a Thunderbird user profile\n\n        Args:\n            user (str): Username for identifying the user profile.\n            profile_key (str): Thunderbird profile key.\n        \"\"\"\n\n        def show_ui():\n            try:\n                if user not in self.mail_archives.mail_archives:\n                    ui.html(f\"Unknown user {user}\")\n                    return\n\n                # Initialize the Thunderbird instance for the given user\n                self.tb = Thunderbird.get(user)\n                # get all mailboxes\n                mboxes_view_lod = self.tb.get_synched_mailbox_view_lod()\n                self.mboxes_view = ListOfDictsGrid(lod=mboxes_view_lod)\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        await self.setup_content_div(show_ui)\n\n    async def show_search(self, user: str, profile_key: str):\n        \"\"\"\n        Shows a search interface for Thunderbird mails.\n\n        Args:\n            user (str): Username for identifying the user profile.\n            profile_key (str): Thunderbird profile key.\n        \"\"\"\n\n        def show_ui():\n            if user not in self.mail_archives.mail_archives:\n                ui.html(f\"Unknown user {user}\")\n                return\n\n            # Initialize the Thunderbird instance for the given user\n            self.tb = Thunderbird.get(user)\n\n            # Define a search dictionary with default values or criteria\n            search_dict = {\n                \"Subject\": \"\",\n                \"From\": \"\",\n                \"To\": \"\",\n                \"Message-ID:\": \"\",\n            }\n            # Initialize MailSearch with the Thunderbird instance and the search dictionary\n            self.mail_search = MailSearch(self, self.tb, search_dict)\n\n        await self.setup_content_div(show_ui)\n\n    def update_mailboxes_grid(self,update_lod):\n        with self.mailboxes_grid_container:\n            self.mailboxes_grid.load_lod(update_lod)\n            self.mailboxes_grid.sizeColumnsToFit()\n\n    def run_indexing(self, tb, progress_bar):\n        \"\"\"\n        prepare and run indexing of mailboxes\n        \"\"\"\n        def update_grid(mailbox,message_count:int):\n            \"\"\"\n            \"\"\"\n            index=len(update_lod)+1\n            if index==1:\n                self.mailboxes_label.text=self.ixs.msg         \n\n            mb_record=mailbox.as_view_record(index=index)\n            mb_record[\"count\"]=message_count\n            update_lod.append(mb_record)\n            self.update_mailboxes_grid(update_lod)\n\n        try:\n            update_lod = []\n            tb.do_create_or_update_index(ixs=self.ixs,progress_bar=progress_bar,callback=update_grid)\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    def run_prepare_indexing(self):\n        try:\n            self.tb.prepare_mailboxes_for_indexing(ixs=self.ixs,progress_bar=self.progress_bar)\n            update_lod=self.ixs.get_update_lod()\n            self.update_mailboxes_grid(update_lod)\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    async def create_or_update_index(self, user: str, profile_key: str) -&gt; None:\n        \"\"\"\n        user interface to start create or updating index\n        \"\"\"\n        async def on_prepare():\n            \"\"\"\n            Handle the prepare button click\n            \"\"\"\n            # force index db update time\n            self.tb.index_db_update_time=None\n            await run.io_bound(self.run_prepare_indexing)\n\n\n        async def on_index():\n            \"\"\"\n            Handle the reindex button click\n            \"\"\"\n            self.ixs.force_create = self.force_create_checkbox.value\n            self.ixs.needs_update=True\n\n            await run.io_bound(self.run_indexing, self.tb, progress_bar=self.progress_bar)\n\n        def show_ui():\n            \"\"\"\n            show my user interface\n            \"\"\"\n            if user not in self.mail_archives.mail_archives:\n                ui.html(f\"Unknown user {user}\")\n            else:\n                self.user = user\n                self.tb = self.mail_archives.mail_archives[user]\n                self.ixs=self.tb.get_indexing_state()\n                self.progress_bar = NiceguiProgressbar(\n                    total=100, desc=\"updating index\", unit=\"mailboxes\"\n                )\n                with ui.row() as self.header_row:\n                    self.state_label=ui.label(self.ixs.state_msg)\n                    self.mailboxes_label=ui.label(\"\")\n                    self.force_create_checkbox = ui.checkbox(\"Force Create\")\n                    self.prepare_button = ui.button(\"Prepare\", on_click=on_prepare)\n                    self.reindex_button = ui.button(\"Reindex\", on_click=on_index)\n                with ui.row() as self.mailboxes_grid_container:\n                    # Create an instance of ListOfDictsGrid to display mailboxes\n                    self.mailboxes_grid = ListOfDictsGrid(lod=[])\n\n        await self.setup_content_div(show_ui)  \n        await run.io_bound(self.run_indexing, self.tb, progress_bar=self.progress_bar)\n\n\n    async def show_folders(self, user: str, profile_key: str) -&gt; None:\n        \"\"\"\n        Asynchronously shows a user's folder contents based on a profile key.\n\n        Args:\n            user (str): Username for identifying the user profile.\n            profile_key (str): Thunderbird profile key\n\n        Returns:\n            None: The function is intended for display purposes only.\n        \"\"\"\n\n        def show_ui():\n            if user not in self.mail_archives.mail_archives:\n                ui.html(f\"Unknown user {user}\")\n            else:\n                self.user = user\n                self.tb = self.mail_archives.mail_archives[user]\n                extensions = {\"Folder\": \".sbd\", \"Mailbox\": \"\"}\n                self.folder_selector = FileSelector(\n                    path=self.tb.local_folders,\n                    extensions=extensions,\n                    handler=self.on_select_folder,\n                )\n\n        await self.setup_content_div(show_ui)\n\n    async def on_select_folder(self, folder_path):\n        \"\"\"\n        open the folder\n        \"\"\"\n        relative_path = ThunderbirdMailbox.as_relative_path(folder_path)\n        url = f\"/folder/{self.user}{relative_path}\"\n        return ui.open(url, new_tab=True)\n\n    async def show_folder(self, user, folder_path: str):\n        \"\"\"\n        show the folder with the given path\n        \"\"\"\n\n        def show_index():\n            try:\n                index_lod = self.folder_mbox.get_toc_lod_from_sqldb(self.tb.index_db)\n                view_lod = ThunderbirdMailbox.to_view_lod(index_lod, user)\n                msg_count = self.folder_mbox.mbox.__len__()\n                with self.folder_view:\n                    self.folder_view.content = f\"{msg_count:5} ({folder_path})\"\n                    self.folder_grid.load_lod(lod=view_lod)\n                    self.folder_grid.sizeColumnsToFit()\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        def show():\n            self.tb = Thunderbird.get(user)\n            self.folder_mbox = ThunderbirdMailbox(self.tb, folder_path, use_relative_path=True)\n            self.folder_view = ui.html()\n            self.folder_view.content = f\"Loading {self.folder_mbox.relative_folder_path} ...\"\n            grid_config = GridConfig(key_col=\"email_index\")\n            self.folder_grid = ListOfDictsGrid(config=grid_config)\n            self.folder_grid.html_columns = [1, 2]\n\n        await self.setup_content_div(show)\n        await run.io_bound(show_index)\n\n\n    async def showMail(self, user: str, mailid: str):\n        \"\"\"\n        Show the given mail of the given user.\n        \"\"\"\n\n        def get_mail():\n            \"\"\"\n            Get the mail.\n            \"\"\"\n            try:\n                mail = self.webserver.get_mail(user, mailid)\n                # check mail has a message\n                if not mail.msg:\n                    title_section = self.sections[\"title\"]\n                    html_markup = mail.as_html_error_msg()\n                    title_section.content_div.content = html_markup\n                else:\n                    for section_name, section in self.sections.items():\n                        html_markup = mail.as_html_section(section_name)\n                        with section.content_div:\n                            section.content_div.content = html_markup\n                            section.update()\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        async def show():\n            try:\n                self.sections = {}\n                section_names = [\n                    \"title\",\n                    \"info\",\n                    \"wiki\",\n                    \"headers\",\n                    \"text\",\n                    \"html\",\n                    \"parts\",\n                ]\n                visible_sections = {\n                    \"title\",\n                    \"info\",\n                    \"text\",\n                    \"html\",\n                }  # Sections to be initially visible\n                self.progress_bar = NiceguiProgressbar(100, \"load mail\", \"steps\")\n                if user in self.mail_archives.mail_archives:\n                    for section_name in section_names:\n                        # Set initial visibility based on the section name\n                        show_content = section_name in visible_sections\n                        self.sections[section_name] = HideShow(\n                            (section_name, section_name),\n                            show_content=show_content,\n                            lazy_init=True,\n                        )\n                    for section_name in section_names:\n                        self.sections[section_name].set_content(ui.html())\n\n                else:\n                    self.mail_view = ui.html(f\"unknown user {user}\")\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        await self.setup_content_div(show)\n        await run.io_bound(get_mail)  \n\n    def setup_content(self):\n        \"\"\"\n        select users\n        \"\"\"\n        self.view_lod = self.mail_archives.as_view_lod()\n        self.lod_grid = ListOfDictsGrid(lod=self.view_lod)\n\n    async def home(self):\n        \"\"\"\n        provide the main content page\n\n        \"\"\"\n        await self.setup_content_div(self.setup_content)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (DynamicCompotenceMapWebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>def __init__(self, webserver: ThunderbirdWebserver, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (DynamicCompotenceMapWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n    self.tb = None\n    self.mail_archives=self.webserver.mail_archives\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.create_or_update_index","title":"<code>create_or_update_index(user, profile_key)</code>  <code>async</code>","text":"<p>user interface to start create or updating index</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def create_or_update_index(self, user: str, profile_key: str) -&gt; None:\n    \"\"\"\n    user interface to start create or updating index\n    \"\"\"\n    async def on_prepare():\n        \"\"\"\n        Handle the prepare button click\n        \"\"\"\n        # force index db update time\n        self.tb.index_db_update_time=None\n        await run.io_bound(self.run_prepare_indexing)\n\n\n    async def on_index():\n        \"\"\"\n        Handle the reindex button click\n        \"\"\"\n        self.ixs.force_create = self.force_create_checkbox.value\n        self.ixs.needs_update=True\n\n        await run.io_bound(self.run_indexing, self.tb, progress_bar=self.progress_bar)\n\n    def show_ui():\n        \"\"\"\n        show my user interface\n        \"\"\"\n        if user not in self.mail_archives.mail_archives:\n            ui.html(f\"Unknown user {user}\")\n        else:\n            self.user = user\n            self.tb = self.mail_archives.mail_archives[user]\n            self.ixs=self.tb.get_indexing_state()\n            self.progress_bar = NiceguiProgressbar(\n                total=100, desc=\"updating index\", unit=\"mailboxes\"\n            )\n            with ui.row() as self.header_row:\n                self.state_label=ui.label(self.ixs.state_msg)\n                self.mailboxes_label=ui.label(\"\")\n                self.force_create_checkbox = ui.checkbox(\"Force Create\")\n                self.prepare_button = ui.button(\"Prepare\", on_click=on_prepare)\n                self.reindex_button = ui.button(\"Reindex\", on_click=on_index)\n            with ui.row() as self.mailboxes_grid_container:\n                # Create an instance of ListOfDictsGrid to display mailboxes\n                self.mailboxes_grid = ListOfDictsGrid(lod=[])\n\n    await self.setup_content_div(show_ui)  \n    await run.io_bound(self.run_indexing, self.tb, progress_bar=self.progress_bar)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>provide the main content page</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def home(self):\n    \"\"\"\n    provide the main content page\n\n    \"\"\"\n    await self.setup_content_div(self.setup_content)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.on_select_folder","title":"<code>on_select_folder(folder_path)</code>  <code>async</code>","text":"<p>open the folder</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def on_select_folder(self, folder_path):\n    \"\"\"\n    open the folder\n    \"\"\"\n    relative_path = ThunderbirdMailbox.as_relative_path(folder_path)\n    url = f\"/folder/{self.user}{relative_path}\"\n    return ui.open(url, new_tab=True)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.run_indexing","title":"<code>run_indexing(tb, progress_bar)</code>","text":"<p>prepare and run indexing of mailboxes</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>def run_indexing(self, tb, progress_bar):\n    \"\"\"\n    prepare and run indexing of mailboxes\n    \"\"\"\n    def update_grid(mailbox,message_count:int):\n        \"\"\"\n        \"\"\"\n        index=len(update_lod)+1\n        if index==1:\n            self.mailboxes_label.text=self.ixs.msg         \n\n        mb_record=mailbox.as_view_record(index=index)\n        mb_record[\"count\"]=message_count\n        update_lod.append(mb_record)\n        self.update_mailboxes_grid(update_lod)\n\n    try:\n        update_lod = []\n        tb.do_create_or_update_index(ixs=self.ixs,progress_bar=progress_bar,callback=update_grid)\n    except Exception as ex:\n        self.handle_exception(ex)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.setup_content","title":"<code>setup_content()</code>","text":"<p>select users</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>def setup_content(self):\n    \"\"\"\n    select users\n    \"\"\"\n    self.view_lod = self.mail_archives.as_view_lod()\n    self.lod_grid = ListOfDictsGrid(lod=self.view_lod)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.showMail","title":"<code>showMail(user, mailid)</code>  <code>async</code>","text":"<p>Show the given mail of the given user.</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def showMail(self, user: str, mailid: str):\n    \"\"\"\n    Show the given mail of the given user.\n    \"\"\"\n\n    def get_mail():\n        \"\"\"\n        Get the mail.\n        \"\"\"\n        try:\n            mail = self.webserver.get_mail(user, mailid)\n            # check mail has a message\n            if not mail.msg:\n                title_section = self.sections[\"title\"]\n                html_markup = mail.as_html_error_msg()\n                title_section.content_div.content = html_markup\n            else:\n                for section_name, section in self.sections.items():\n                    html_markup = mail.as_html_section(section_name)\n                    with section.content_div:\n                        section.content_div.content = html_markup\n                        section.update()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    async def show():\n        try:\n            self.sections = {}\n            section_names = [\n                \"title\",\n                \"info\",\n                \"wiki\",\n                \"headers\",\n                \"text\",\n                \"html\",\n                \"parts\",\n            ]\n            visible_sections = {\n                \"title\",\n                \"info\",\n                \"text\",\n                \"html\",\n            }  # Sections to be initially visible\n            self.progress_bar = NiceguiProgressbar(100, \"load mail\", \"steps\")\n            if user in self.mail_archives.mail_archives:\n                for section_name in section_names:\n                    # Set initial visibility based on the section name\n                    show_content = section_name in visible_sections\n                    self.sections[section_name] = HideShow(\n                        (section_name, section_name),\n                        show_content=show_content,\n                        lazy_init=True,\n                    )\n                for section_name in section_names:\n                    self.sections[section_name].set_content(ui.html())\n\n            else:\n                self.mail_view = ui.html(f\"unknown user {user}\")\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    await self.setup_content_div(show)\n    await run.io_bound(get_mail)  \n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.show_folder","title":"<code>show_folder(user, folder_path)</code>  <code>async</code>","text":"<p>show the folder with the given path</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def show_folder(self, user, folder_path: str):\n    \"\"\"\n    show the folder with the given path\n    \"\"\"\n\n    def show_index():\n        try:\n            index_lod = self.folder_mbox.get_toc_lod_from_sqldb(self.tb.index_db)\n            view_lod = ThunderbirdMailbox.to_view_lod(index_lod, user)\n            msg_count = self.folder_mbox.mbox.__len__()\n            with self.folder_view:\n                self.folder_view.content = f\"{msg_count:5} ({folder_path})\"\n                self.folder_grid.load_lod(lod=view_lod)\n                self.folder_grid.sizeColumnsToFit()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    def show():\n        self.tb = Thunderbird.get(user)\n        self.folder_mbox = ThunderbirdMailbox(self.tb, folder_path, use_relative_path=True)\n        self.folder_view = ui.html()\n        self.folder_view.content = f\"Loading {self.folder_mbox.relative_folder_path} ...\"\n        grid_config = GridConfig(key_col=\"email_index\")\n        self.folder_grid = ListOfDictsGrid(config=grid_config)\n        self.folder_grid.html_columns = [1, 2]\n\n    await self.setup_content_div(show)\n    await run.io_bound(show_index)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.show_folders","title":"<code>show_folders(user, profile_key)</code>  <code>async</code>","text":"<p>Asynchronously shows a user's folder contents based on a profile key.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>Username for identifying the user profile.</p> required <code>profile_key</code> <code>str</code> <p>Thunderbird profile key</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function is intended for display purposes only.</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def show_folders(self, user: str, profile_key: str) -&gt; None:\n    \"\"\"\n    Asynchronously shows a user's folder contents based on a profile key.\n\n    Args:\n        user (str): Username for identifying the user profile.\n        profile_key (str): Thunderbird profile key\n\n    Returns:\n        None: The function is intended for display purposes only.\n    \"\"\"\n\n    def show_ui():\n        if user not in self.mail_archives.mail_archives:\n            ui.html(f\"Unknown user {user}\")\n        else:\n            self.user = user\n            self.tb = self.mail_archives.mail_archives[user]\n            extensions = {\"Folder\": \".sbd\", \"Mailbox\": \"\"}\n            self.folder_selector = FileSelector(\n                path=self.tb.local_folders,\n                extensions=extensions,\n                handler=self.on_select_folder,\n            )\n\n    await self.setup_content_div(show_ui)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.show_mailboxes","title":"<code>show_mailboxes(user, profile_key)</code>  <code>async</code>","text":"<p>Shows a mailboxes for a Thunderbird user profile</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>Username for identifying the user profile.</p> required <code>profile_key</code> <code>str</code> <p>Thunderbird profile key.</p> required Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def show_mailboxes(self, user: str, profile_key: str):\n    \"\"\"\n    Shows a mailboxes for a Thunderbird user profile\n\n    Args:\n        user (str): Username for identifying the user profile.\n        profile_key (str): Thunderbird profile key.\n    \"\"\"\n\n    def show_ui():\n        try:\n            if user not in self.mail_archives.mail_archives:\n                ui.html(f\"Unknown user {user}\")\n                return\n\n            # Initialize the Thunderbird instance for the given user\n            self.tb = Thunderbird.get(user)\n            # get all mailboxes\n            mboxes_view_lod = self.tb.get_synched_mailbox_view_lod()\n            self.mboxes_view = ListOfDictsGrid(lod=mboxes_view_lod)\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    await self.setup_content_div(show_ui)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdSolution.show_search","title":"<code>show_search(user, profile_key)</code>  <code>async</code>","text":"<p>Shows a search interface for Thunderbird mails.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>Username for identifying the user profile.</p> required <code>profile_key</code> <code>str</code> <p>Thunderbird profile key.</p> required Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def show_search(self, user: str, profile_key: str):\n    \"\"\"\n    Shows a search interface for Thunderbird mails.\n\n    Args:\n        user (str): Username for identifying the user profile.\n        profile_key (str): Thunderbird profile key.\n    \"\"\"\n\n    def show_ui():\n        if user not in self.mail_archives.mail_archives:\n            ui.html(f\"Unknown user {user}\")\n            return\n\n        # Initialize the Thunderbird instance for the given user\n        self.tb = Thunderbird.get(user)\n\n        # Define a search dictionary with default values or criteria\n        search_dict = {\n            \"Subject\": \"\",\n            \"From\": \"\",\n            \"To\": \"\",\n            \"Message-ID:\": \"\",\n        }\n        # Initialize MailSearch with the Thunderbird instance and the search dictionary\n        self.mail_search = MailSearch(self, self.tb, search_dict)\n\n    await self.setup_content_div(show_ui)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdWebserver","title":"<code>ThunderbirdWebserver</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>webserver for Thunderbird mail access via python</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>class ThunderbirdWebserver(InputWebserver):\n    \"\"\"\n    webserver for Thunderbird mail access via python\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        \"\"\"\n        get the configuration for this Webserver\n        \"\"\"\n        copy_right = \"(c)2020-2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right, \n            version=Version(), \n            short_name=\"tbmail\",\n            default_port=8482,\n            timeout=15.0\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = ThunderbirdSolution\n        return server_config\n\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        InputWebserver.__init__(self, config=ThunderbirdWebserver.get_config())\n\n        @app.get(\"/part/{user}/{mailid}/{part_index:int}\")\n        async def get_part(user: str, mailid: str, part_index: int):\n            return await self.get_part(\n                user, mailid, part_index\n            )\n\n        @app.get(\"/mail/{user}/{mailid}.wiki\")\n        def get_mail_wikimarkup(user: str, mailid: str):\n            mail = self.get_mail(user, mailid)\n            if (\n                not mail.msg\n            ):  # Assuming mail objects have a 'msg' attribute to check if the message exists\n                html_markup = mail.as_html_error_msg()\n\n                raise HTTPException(status_code=404, detail=html_markup)\n            response = Response(content=mail.asWikiMarkup(), media_type=\"text/plain\")\n            return response\n\n        @ui.page(\"/mail/{user}/{mailid}\")\n        async def showMail(client: Client,user: str, mailid: str):\n            return await self.page(\n                client,ThunderbirdSolution.showMail,\n                user, mailid\n            )\n\n        @ui.page(\"/folder/{user}/{folder_path:path}\")\n        async def showFolder(client: Client,user: str, folder_path: str):\n            return await self.page(\n                client,ThunderbirdSolution.show_folder,\n                user, folder_path\n            )\n\n        @ui.page(\"/profile/{user}/{profile_key}/mailboxes\")\n        async def show_mailboxes(client: Client,user: str, profile_key: str):\n            return await self.page(\n                client,ThunderbirdSolution.show_mailboxes,\n                user, profile_key\n            )\n\n        @ui.page(\"/profile/{user}/{profile_key}/search\")\n        async def show_search(client: Client,user: str, profile_key: str):\n            return await self.page(\n                client,ThunderbirdSolution.show_search,\n                user, profile_key\n            )\n\n        @ui.page(\"/profile/{user}/{profile_key}/index\")\n        async def create_or_update_index(client: Client,user: str, profile_key: str):\n            return await self.page(\n                client,ThunderbirdSolution.create_or_update_index,\n                user, profile_key\n            )\n\n        @ui.page(\"/profile/{user}/{profile_key}\")\n        async def show_folders(client: Client,user: str, profile_key: str):\n            return await self.page(\n                client,ThunderbirdSolution.show_folders,\n                user, profile_key\n            )\n\n    def configure_run(self):\n        \"\"\"\n        configure me e.g. the allowed urls\n        \"\"\"\n        InputWebserver.configure_run(self)\n        # If args.user_list is None or empty, use users from the profiles\n        # see https://github.com/WolfgangFahl/pyThunderbird/issues/19\n        if not self.args.user_list:\n            profile_map = Thunderbird.getProfileMap()\n            user_list = list(profile_map.keys())\n        else:\n            user_list = self.args.user_list\n\n        self.mail_archives = MailArchives(user_list)\n\n    def get_mail(self, user: str, mailid: str) -&gt; Any:\n        \"\"\"\n        Retrieves a specific mail for a given user by its mail identifier.\n\n        Args:\n            user (str): The username of the individual whose mail is to be retrieved.\n            mailid (str): The unique identifier for the mail to be retrieved.\n\n        Returns:\n            Any: Returns an instance of the Mail class corresponding to the specified `mailid` for the `user`.\n\n        Raises:\n            HTTPException: If the user is not found in the mail archives, an HTTP exception with status code 404 is raised.\n        \"\"\"\n        if user not in self.mail_archives.mail_archives:\n            raise HTTPException(status_code=404, detail=f\"User '{user}' not found\")\n        tb = self.mail_archives.mail_archives[user]\n        mail = Mail(user=user, mailid=mailid, tb=tb, debug=self.debug)\n        return mail\n\n    async def get_part(self, user: str, mailid: str, part_index: int) -&gt; FileResponse:\n        \"\"\"\n        Asynchronously retrieves a specific part of a mail for a given user, identified by the mail's unique ID and the part index.\n\n        Args:\n            user (str): The username of the individual whose mail part is to be retrieved.\n            mailid (str): The unique identifier for the mail whose part is to be retrieved.\n            part_index (int): The index of the part within the mail to retrieve.\n\n        Returns:\n            FileResponse: A file response object containing the specified part of the mail.\n\n        Raises:\n            HTTPException: If the user or the specified mail part does not exist, an HTTP exception could be raised.\n\n       \"\"\"      \n        tb = self.mail_archives.mail_archives[user]\n        mail = Mail(user=user, mailid=mailid, tb=tb, debug=self.debug)\n        response = mail.part_as_fileresponse(part_index)\n        return response\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdWebserver.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructor\"\"\"\n    InputWebserver.__init__(self, config=ThunderbirdWebserver.get_config())\n\n    @app.get(\"/part/{user}/{mailid}/{part_index:int}\")\n    async def get_part(user: str, mailid: str, part_index: int):\n        return await self.get_part(\n            user, mailid, part_index\n        )\n\n    @app.get(\"/mail/{user}/{mailid}.wiki\")\n    def get_mail_wikimarkup(user: str, mailid: str):\n        mail = self.get_mail(user, mailid)\n        if (\n            not mail.msg\n        ):  # Assuming mail objects have a 'msg' attribute to check if the message exists\n            html_markup = mail.as_html_error_msg()\n\n            raise HTTPException(status_code=404, detail=html_markup)\n        response = Response(content=mail.asWikiMarkup(), media_type=\"text/plain\")\n        return response\n\n    @ui.page(\"/mail/{user}/{mailid}\")\n    async def showMail(client: Client,user: str, mailid: str):\n        return await self.page(\n            client,ThunderbirdSolution.showMail,\n            user, mailid\n        )\n\n    @ui.page(\"/folder/{user}/{folder_path:path}\")\n    async def showFolder(client: Client,user: str, folder_path: str):\n        return await self.page(\n            client,ThunderbirdSolution.show_folder,\n            user, folder_path\n        )\n\n    @ui.page(\"/profile/{user}/{profile_key}/mailboxes\")\n    async def show_mailboxes(client: Client,user: str, profile_key: str):\n        return await self.page(\n            client,ThunderbirdSolution.show_mailboxes,\n            user, profile_key\n        )\n\n    @ui.page(\"/profile/{user}/{profile_key}/search\")\n    async def show_search(client: Client,user: str, profile_key: str):\n        return await self.page(\n            client,ThunderbirdSolution.show_search,\n            user, profile_key\n        )\n\n    @ui.page(\"/profile/{user}/{profile_key}/index\")\n    async def create_or_update_index(client: Client,user: str, profile_key: str):\n        return await self.page(\n            client,ThunderbirdSolution.create_or_update_index,\n            user, profile_key\n        )\n\n    @ui.page(\"/profile/{user}/{profile_key}\")\n    async def show_folders(client: Client,user: str, profile_key: str):\n        return await self.page(\n            client,ThunderbirdSolution.show_folders,\n            user, profile_key\n        )\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdWebserver.configure_run","title":"<code>configure_run()</code>","text":"<p>configure me e.g. the allowed urls</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>def configure_run(self):\n    \"\"\"\n    configure me e.g. the allowed urls\n    \"\"\"\n    InputWebserver.configure_run(self)\n    # If args.user_list is None or empty, use users from the profiles\n    # see https://github.com/WolfgangFahl/pyThunderbird/issues/19\n    if not self.args.user_list:\n        profile_map = Thunderbird.getProfileMap()\n        user_list = list(profile_map.keys())\n    else:\n        user_list = self.args.user_list\n\n    self.mail_archives = MailArchives(user_list)\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdWebserver.get_config","title":"<code>get_config()</code>  <code>classmethod</code>","text":"<p>get the configuration for this Webserver</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>@classmethod\ndef get_config(cls) -&gt; WebserverConfig:\n    \"\"\"\n    get the configuration for this Webserver\n    \"\"\"\n    copy_right = \"(c)2020-2024 Wolfgang Fahl\"\n    config = WebserverConfig(\n        copy_right=copy_right, \n        version=Version(), \n        short_name=\"tbmail\",\n        default_port=8482,\n        timeout=15.0\n    )\n    server_config = WebserverConfig.get(config)\n    server_config.solution_class = ThunderbirdSolution\n    return server_config\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdWebserver.get_mail","title":"<code>get_mail(user, mailid)</code>","text":"<p>Retrieves a specific mail for a given user by its mail identifier.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The username of the individual whose mail is to be retrieved.</p> required <code>mailid</code> <code>str</code> <p>The unique identifier for the mail to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Returns an instance of the Mail class corresponding to the specified <code>mailid</code> for the <code>user</code>.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is not found in the mail archives, an HTTP exception with status code 404 is raised.</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>def get_mail(self, user: str, mailid: str) -&gt; Any:\n    \"\"\"\n    Retrieves a specific mail for a given user by its mail identifier.\n\n    Args:\n        user (str): The username of the individual whose mail is to be retrieved.\n        mailid (str): The unique identifier for the mail to be retrieved.\n\n    Returns:\n        Any: Returns an instance of the Mail class corresponding to the specified `mailid` for the `user`.\n\n    Raises:\n        HTTPException: If the user is not found in the mail archives, an HTTP exception with status code 404 is raised.\n    \"\"\"\n    if user not in self.mail_archives.mail_archives:\n        raise HTTPException(status_code=404, detail=f\"User '{user}' not found\")\n    tb = self.mail_archives.mail_archives[user]\n    mail = Mail(user=user, mailid=mailid, tb=tb, debug=self.debug)\n    return mail\n</code></pre>"},{"location":"#thunderbird.tb_webserver.ThunderbirdWebserver.get_part","title":"<code>get_part(user, mailid, part_index)</code>  <code>async</code>","text":"<p>Asynchronously retrieves a specific part of a mail for a given user, identified by the mail's unique ID and the part index.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The username of the individual whose mail part is to be retrieved.</p> required <code>mailid</code> <code>str</code> <p>The unique identifier for the mail whose part is to be retrieved.</p> required <code>part_index</code> <code>int</code> <p>The index of the part within the mail to retrieve.</p> required <p>Returns:</p> Name Type Description <code>FileResponse</code> <code>FileResponse</code> <p>A file response object containing the specified part of the mail.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user or the specified mail part does not exist, an HTTP exception could be raised.</p> Source code in <code>thunderbird/tb_webserver.py</code> <pre><code>async def get_part(self, user: str, mailid: str, part_index: int) -&gt; FileResponse:\n    \"\"\"\n    Asynchronously retrieves a specific part of a mail for a given user, identified by the mail's unique ID and the part index.\n\n    Args:\n        user (str): The username of the individual whose mail part is to be retrieved.\n        mailid (str): The unique identifier for the mail whose part is to be retrieved.\n        part_index (int): The index of the part within the mail to retrieve.\n\n    Returns:\n        FileResponse: A file response object containing the specified part of the mail.\n\n    Raises:\n        HTTPException: If the user or the specified mail part does not exist, an HTTP exception could be raised.\n\n   \"\"\"      \n    tb = self.mail_archives.mail_archives[user]\n    mail = Mail(user=user, mailid=mailid, tb=tb, debug=self.debug)\n    response = mail.part_as_fileresponse(part_index)\n    return response\n</code></pre>"},{"location":"#thunderbird.version","title":"<code>version</code>","text":"<p>Created on 2023-11-23</p> <p>@author: wf</p>"},{"location":"#thunderbird.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyThunderbird</p> Source code in <code>thunderbird/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for pyThunderbird\n    \"\"\"\n\n    name = \"pyThunderbird\"\n    version = thunderbird.__version__\n    description = \"python based access to Thunderbird mail\"\n    date = \"2021-09-23\"\n    updated = \"2024-08-01\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/pyThunderbird\"\n    chat_url = \"https://github.com/WolfgangFahl/pyThunderbird/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/pyThunderbird\"\n\n    license = f\"\"\"Copyright 2020-2023 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"}]}